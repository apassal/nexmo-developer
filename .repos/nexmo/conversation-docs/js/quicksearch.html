<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"application.js.html":{"id":"application.js.html","title":"Source: application.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: application.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Application Object Model * * Copyright (c) Nexmo Inc. */ const WildEmitter = require('wildemitter'); const getLogger = require('loglevel').getLogger; const nexmoClientError_1 = require(\"./nexmoClientError\"); const user_1 = __importDefault(require(\"./user\")); const conversation_1 = __importDefault(require(\"./conversation\")); const nxmCall_1 = __importDefault(require(\"./modules/nxmCall\")); const sip_events_1 = __importDefault(require(\"./handlers/sip_events\")); const rtc_events_1 = __importDefault(require(\"./handlers/rtc_events\")); const application_events_1 = __importDefault(require(\"./handlers/application_events\")); const utils_1 = __importDefault(require(\"./utils\")); const page_config_1 = __importDefault(require(\"./pages/page_config\")); const conversations_page_1 = __importDefault(require(\"./pages/conversations_page\")); let sipEventHandler = null; let rtcEventHandler = null; let applicationEventsHandler = null; /** * Core application class for the SDK. * Application is the parent object holding the list of conversations, the session object. * Provides methods to create conversations and retrieve a list of the user's conversations, while it holds the listeners for * user's invitations * @class Application * @param {NexmoClient} SDK session Object * @param {object} params * @example &lt;caption&gt;Accessing the list of conversations&lt;/caption&gt; * rtc.login(token).then((application) =&gt; { * console.log(application.conversations); * console.log(application.me.name, application.me.id); * }); * @emits Application#member:invited * @emits Application#member:joined * @emits Application#NXM-errors */ class Application { constructor(session, params) { this.log = getLogger(this.constructor.name); this.session = session; this.conversations = new Map(); this.synced_conversations_count = 0; this.start_sync_time = 0; this.stop_sync_time = 0; // conversation_id, nxmCall this.calls = new Map(); // knocking_id, nxmCall this._call_draft_list = new Map(); this.pageConfig = new page_config_1.default((session.config || {}).conversations_page_config); this.conversations_page_last = null; sipEventHandler = new sip_events_1.default(this); rtcEventHandler = new rtc_events_1.default(this); applicationEventsHandler = new application_events_1.default(this); this.me = null; Object.assign(this, params); WildEmitter.mixin(Application); } /** * Update Conversation instance or create a new one. * * Pre-created conversation exist from getConversations * like initialised templates. When we explicitly ask to * getConversation(), we receive members and other details * * @param {object} payload Conversation payload * @private */ updateOrCreateConversation(payload) { const conversation = this.conversations.get(payload.id); if (conversation) { conversation._updateObjectInstance(payload); this.conversations.set(payload.id, conversation); } else { this.conversations.set(payload.id, new conversation_1.default(this, payload)); } return this.conversations.get(payload.id); } /** * Application listening for invites. * * @event Application#member:invited * * @property {Member} member - The invited member * @property {NXMEvent} event - The invitation event * * @example &lt;caption&gt;listen for your invites&lt;/caption&gt; * application.on(\"member:invited\",(member, event) =&gt; { * console.log(\"Invited to the conversation: \" + event.conversation.display_name || event.conversation.name); * // identify the sender. * console.log(\"Invited by: \" + member.invited_by); * //accept an invitation. * application.conversations.get(event.conversation.id).join(); * //decline the invitation. * application.conversations.get(event.conversation.id).leave(); */ /** * Application listening for joins. * * @event Application#member:joined * * @property {Member} member - the member that joined the conversation * @property {NXMEvent} event - the join event * * @example &lt;caption&gt;listen join events in Application level&lt;/caption&gt; * application.on(\"member:joined\",(member, event) =&gt; { * console.log(\"JOINED\", \"Joined conversation: \" + event.conversation.display_name || event.conversation.name); * }); */ /** * Entry point for events in Application level * @private */ _handleEvent(event) { const isEventFromMe = event.body &amp;&amp; event.body.user &amp;&amp; event.body.user.user_id === this.me.id; if (event.type.startsWith('sip')) { sipEventHandler._handleSipCallEvent(event); return; } if (this.conversations.has(event.cid)) { if (event.type.startsWith('rtc')) { rtcEventHandler._handleRtcEvent(event); } this.conversations.get(event.cid)._handleEvent(event); if ((event.type === 'member:joined' || event.type === 'member:invited') &amp;&amp; isEventFromMe) { this._handleApplicationEvent(event); } } else { // get the conversation you don't know about (case: joined by another user) this.getConversation(event.cid) .then((conversation) =&gt; { this.conversations.set(event.cid, conversation); conversation._handleEvent(event); this._handleApplicationEvent(event); if (event.type.startsWith('rtc')) { rtcEventHandler._handleRtcEvent(event); } }).catch((error) =&gt; { this.log.error(error); }); } } /** * update user's token * @param {string} token - the new token * @returns {Promise} */ updateToken(token) { return new Promise((resolve, reject) =&gt; { this.session.sendRequest({ type: 'session:update-token', body: { token } }, (response) =&gt; { if (response.type === 'session:update-token:success') { if (this.me) { this.session.config.token = token; } resolve(); } else { reject(new nexmoClientError_1.NexmoApiError(response)); } }); }); } /** * Update the event to map local generated events * in case we need a more specific event to pass in the application listener * or f/w the event as it comes * @private */ _handleApplicationEvent(event) { const processed_event = applicationEventsHandler.handleEvent(event); this.emit(processed_event.type, this.conversations.get(event.cid).members.get(processed_event.from), processed_event); } /** * Creates a call to specified user/s. * @classdesc creates a call between the defined users * @param {string[]} usernames - the user names for those we want to call * @returns {Promise&lt;NXMCall&gt;} a NXMCall object with all the call properties */ async inAppCall(usernames) { if (!usernames || !Array.isArray(usernames) || usernames.length === 0) { return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params')); } try { const nxmCall = new nxmCall_1.default(this); await nxmCall.createCall(usernames); nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND; return nxmCall; } catch (error) { throw error; } } /** * Creates a call to phone a number. * The call object is created under application.calls when the call has started. * listen for it with application.on(\"call:status:changed\") * * You don't need to start the stream, the SDK will play the audio for you * * @classdesc creates a call to a phone number * @param {string} user the phone number or the username you want to call * @param {string} [type=\"phone\"] the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\") * @returns {Promise&lt;NXMCall&gt;} * @example &lt;caption&gt;Create a call to a phone&lt;/caption&gt; * application.on(\"call:status:changed\", (nxmCall) =&gt; { * if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) { * console.log('the call has started'); * } * }); * * application.callServer(phone_number).then(() =&gt; { * console.log('Calling phone ' + phone_number); * }); */ async callServer(user, type = 'phone') { try { const nxmCall = new nxmCall_1.default(this); nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND; const { id } = await nxmCall.createServerCall(user, type); nxmCall.knocking_id = id; return nxmCall; } catch (error) { throw error; } } /** * Query the service to create a new conversation * The conversation name must be unique per application. * @param {object} [params] - leave empty to get a GUID as name * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped * @param {string} params.display_name - the display_name of the conversation. * @returns {Promise&lt;Conversation&gt;} - the created Conversation * @example &lt;caption&gt;Create a conversation and join&lt;/caption&gt; * application.newConversation().then((conversation) =&gt; { * //join the created conversation * conversation.join().then((member) =&gt; { * //Get the user's member belonging in this conversation. * //You can also access it via conversation.me * console.log(\"Joined as \" + member.user.name); * }).catch((error) =&gt; { * console.log(error); * }); */ async newConversation(data = {}) { try { const response = await this.session.sendNetworkRequest({ type: 'POST', path: 'conversations', data }); const conv = new conversation_1.default(this, response); this.conversations.set(conv.id, conv); // do a get conversation to get the whole model as shaped in the service, return this.getConversation(conv.id); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Query the service to create a new conversation and join it * The conversation name must be unique per application. * @param {object} [params] - leave empty to get a GUID as name * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped * @param {string} params.display_name - the display_name of the conversation. * @returns {Promise&lt;Conversation&gt;} - the created Conversation * @example &lt;caption&gt;Create a conversation and join&lt;/caption&gt; * application.newConversationAndJoin().then((conversation) =&gt; { * //join the created conversation * conversation.join().then((member) =&gt; { * //Get the user's member belonging in this conversation. * //You can also access it via conversation.me * console.log(\"Joined as \" + member.user.name); * }).catch((error) =&gt; { * console.log(error); * }); */ newConversationAndJoin(params) { return this.newConversation(params).then((conversation) =&gt; { return conversation.join().then(() =&gt; { return conversation; }); }); } /** * Query the service to see if this conversation exists with the * logged in user as a member and retrieve the data object * Result added (or updated) in this.conversations * * @param {string} id - the id of the conversation to fetch * @returns {Promise&lt;Conversation&gt;} - the requested conversation */ async getConversation(id) { try { const response = await this.session.sendNetworkRequest({ type: 'GET', path: `conversations/${id}` }); response['id'] = response['uuid']; delete response['uuid']; const conversation_object = this.updateOrCreateConversation(response); if (this.session.config.sync === 'full') { // Populate the events const { items } = await conversation_object.getEvents(); conversation_object.events = items; return conversation_object; } else { return conversation_object; } } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Query the service to obtain a complete list of conversations of which the * logged-in user is a member with a state of `JOINED` or `INVITED`. * @param {object} params configure defaults for paginated conversations query * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time * @param {number} params.page_size the number of resources returned in a single request list * @param {string} [params.cursor] string to access the starting point of a dataset * * @returns {Promise&lt;Page&lt;Map&lt;Conversation&gt;&gt;&gt;} - Populate Application.conversations. * @example &lt;caption&gt;Get Conversations&lt;/caption&gt; * application.getConversations({ page_size: 20 ).then((conversations_page) =&gt; { * conversations_page.items.forEach(conversation =&gt; { * render(conversation) * }) * }); * */ async getConversations(params = {}) { const url = `${this.session.config.nexmo_api_url}/beta2/users/${this.me.id}/conversations`; // Create pageConfig if some elements given otherwise use default let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params); try { const response = await utils_1.default.paginationRequest(url, pageConfig, this.session.config.token); response.application = this; const conversations_page = new conversations_page_1.default(response); this.conversations_page_last = conversations_page; return conversations_page; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Application listening sync status. * * @event Application#sync:progress * * @property {number} status.sync_progress - Percentage of fetched conversations * @example &lt;caption&gt;listening for changes in the synchronisation progress&lt;/caption&gt; * application.on(\"sync:progress\",(status) =&gt; { * console.log(data.sync_progress); * }); */ /** * Fetching all the conversations and sync progress events */ syncConversations(conversations) { const conversation_array = Array.from(conversations.values()); const conversations_length = conversation_array.length; const d = new Date(); this.start_sync_time = (typeof window !== 'undefined' &amp;&amp; window.performance) ? window.performance.now() : d.getTime(); const fetchConversationForStorage = () =&gt; { this.synced_conversations_percentage = Number(((this.synced_conversations_count / conversations_length) * 100).toFixed(2)); const status_payload = { sync_progress: this.synced_conversations_percentage }; this.emit('sync:progress', status_payload); this.log.info('Loading sync progress: ' + this.synced_conversations_count + '/' + conversations_length + ' - ' + this.synced_conversations_percentage + '%'); if (this.synced_conversations_percentage &gt;= 100) { const d = new Date(); this.stop_sync_time = (typeof window !== 'undefined' &amp;&amp; window.performance) ? window.performance.now() : d.getTime(); this.log.info('Loaded conversations in ' + (this.stop_sync_time - this.start_sync_time) + 'ms'); } if (this.synced_conversations_count &lt; conversations_length) { this.getConversation(conversation_array[this.synced_conversations_count].id).then(() =&gt; { fetchConversationForStorage(); }); this.synced_conversations_count++; this.sync_progress_buffer++; } }; fetchConversationForStorage(); } /** * Get Details of a user * @param {string} [id] - the id of the user to fetch, if skipped, it returns your own user details * @returns {Promise&lt;User&gt;} */ async getUser(user_id = this.me.id) { try { const response = await this.session.sendNetworkRequest({ type: 'GET', path: `users/${user_id}` }); return new user_1.default(this, response); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } } exports.default = Application; module.exports = Application; × Search results Close "},"modules_nxmCall.js.html":{"id":"modules_nxmCall.js.html","title":"Source: modules/nxmCall.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: modules/nxmCall.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * NXMCall Object Model * * Copyright (c) Nexmo Inc. */ const WildEmitter = require('wildemitter'); const getLogger = require('loglevel').getLogger; const nexmoClientError_1 = require(\"../nexmoClientError\"); const utils_1 = __importDefault(require(\"../utils\")); /** * Conversation NXMCall Object. * @class NXMCall * @param {Application} application - The Application object. * @param {Conversation} conversation - The Conversation object that belongs to this nxmCall. * @param {Member} from - The member that initiated the nxmCall. * @property {Application} application - The Application object that the nxmCall belongs to. * @property {Conversation} conversation - The Conversation object that belongs to this nxmCall. * @property {Member} from - The caller. The member object of the caller (not a reference to the one in conversation.members) * @property {Map&lt;string, Member&gt;} to - The callees keyed by a member's id. The members that receive the nxmCall (not a reference to conversation.members) * @property {String} id - The nxmCall id (our member's leg_id, comes from rtc:answer event, or member:media) * @property {NXMCall.CALL_STATUS} CALL_STATUS=\"started\" - the available nxmCall statuses * @property {NXMCall.CALL_DIRECTION} direction - the Direction of the nxmCall, Outbound, Inbound * @property {NXMCall.STATUS_PERMITTED_FLOW} STATUS_PERMITTED_FLOW - the permitted nxmCall status transition map, describes the \"from\" and allowed \"to\" transitions * @emits Application#member:call * @emits Application#call:status:changed */ /** * Application listening for calls. * * @event Application#member:call * * @property {Member} member - the member that initiated the nxmCall * @property {NXMCall} nxmCall - resolves the nxmCall object * * @example &lt;caption&gt;listen for calls in Application level&lt;/caption&gt; * application.on(\"member:call\", (member, nxmCall) =&gt; { * console.log(\"NXMCall \", nxmCall); * }); */ /** * NXMCall listening for nxmCall status changed events. * * @event Application#call:status:changed * @property {NXMCall} nxmCall - the actual event * @example &lt;caption&gt;listen for nxmCall status events&lt;/caption&gt; * application.on(\"call:status:changed\",(nxmCall) =&gt; { * console.log(\"call: \" + nxmCall.status); * }); */ class NXMCall { constructor(application, conversation, from) { this.application = application; this.log = getLogger(this.constructor.name); this.from = from; this.conversation = null; /** * Enum for NXMCall status. * @readonly * @enum {string} * @alias NXMCall.CALL_STATUS */ this.CALL_STATUS = { /** The NXMCall is in started status */ STARTED: 'started', /** The NXMCall is in ringing status */ RINGING: 'ringing', /** The NXMCall is in answered status */ ANSWERED: 'answered', /** The NXMCall is in completed status */ COMPLETED: 'completed', /** The NXMCall is in busy status */ BUSY: 'busy', /** The NXMCall is in timeout status */ TIMEOUT: 'timeout', /** The NXMCall is in unanswered status */ UNANSWERED: 'unanswered', /** The NXMCall is in rejected status */ REJECTED: 'rejected', /** The NXMCall is in failed status */ FAILED: 'failed' }; /** * Enum for NXMCall direction. * @readonly * @enum {string} * @alias NXMCall.CALL_DIRECTION */ this.CALL_DIRECTION = { /** The NXMCall started from another end */ INBOUND: 'inbound', /** The NXMCall started from this client */ OUTBOUND: 'outbound' }; Object.freeze(this.CALL_DIRECTION); /** * Enum for the permitted call status transition. * @readonly * @alias NXMCall.STATUS_PERMITTED_FLOW * @enum {Map&lt;string, Set&lt;NXMCall.CALL_STATUS&gt;&gt;} */ this.STATUS_PERMITTED_FLOW = new Map([ /** Permitted transition array from STARTED */ ['STARTED', new Set([ this.CALL_STATUS.RINGING, this.CALL_STATUS.ANSWERED, this.CALL_STATUS.FAILED, this.CALL_STATUS.TIMEOUT, this.CALL_STATUS.UNANSWERED, this.CALL_STATUS.REJECTED, this.CALL_STATUS.BUSY ])], /** Permitted transition array from RINGING */ ['RINGING', new Set([ this.CALL_STATUS.ANSWERED, this.CALL_STATUS.FAILED, this.CALL_STATUS.TIMEOUT, this.CALL_STATUS.UNANSWERED, this.CALL_STATUS.REJECTED, this.CALL_STATUS.BUSY ])], /** Permitted transition set from ANSWERED */ ['ANSWERED', new Set([ this.CALL_STATUS.COMPLETED, this.CALL_STATUS.FAILED ])] ]); Object.freeze(this.STATUS_PERMITTED_FLOW); this.status = null; this.direction = this.CALL_DIRECTION.INBOUND; this._setupConversationObject(conversation); WildEmitter.mixin(NXMCall); } /** * Enable NXMCall stats to be emitted in application.inAppCall.on('call:stats:report'); * @private */ _enableStatsEvents() { if (this.application.session.config &amp;&amp; this.application.session.config.rtcstats &amp;&amp; this.application.session.config.rtcstats.emit_events) { return this.conversation.media._enableStatsEvents(); } } /** * Attach member event listeners from the conversation * @private */ _attachCallListeners() { // Conversation level listeners this.conversation.releaseGroup('call_module'); this.conversation.on('member:media', 'call_module', (from, event) =&gt; { if (this.application.calls &amp;&amp; this.application.calls.has(this.conversation.id)) { this.application.calls.get(this.conversation.id)._handleStatusChange(event); } }); } /** * Validate the current nxmCall status transition * If a transition is not defined, return false * @param {string} status the status to validate * @returns {boolean} false if the transition is not permitted * @private */ _isValidStatusTransition(status) { if (!status) { throw new nexmoClientError_1.NexmoClientError(`Provide the status to validate the transition from '${this.status}'`); } // if the nxmCall object is just initialised allow any state if (!this.status) { return true; } const current_status = this.status.toUpperCase(); if (!this.STATUS_PERMITTED_FLOW.has(current_status)) { return false; } if (this.status === status) { return false; } return (this.STATUS_PERMITTED_FLOW.get(current_status).has(status)); } /** * Go through the members of the conversation and if .me is the only one (JOINED or INVITED) * nxmCall nxmCall.hangUp(). * @returns {Promise} - empty promise or the nxmCall.hangUp promise chain */ hangUpIfAllLeft() { if (!this.conversation.me || this.conversation.me.state === 'LEFT' || this.conversation.members.size &lt;= 1) { return Promise.resolve(); } for (let member of this.conversation.members.values()) { if (member.state !== 'LEFT' &amp;&amp; (this.conversation.me.user.id !== member.user.id)) { return Promise.resolve(); } } return this.hangUp(); } /** * Set the conversation object of the NXMCall * update nxmCall.from, and nxmCall.to attributes based on the conversation members * @private */ _setupConversationObject(conversation) { if (!conversation) return; this.conversation = conversation; if (!conversation.me) { this.log.warn('missing own member object'); } else { this.to = new Map(conversation.members); if (this.from) { this.to.delete(this.from.id); } } this._attachCallListeners(); } /** * Set the from object of the NXMCall * @private */ _setFrom(from) { this.from = from; } /** * Process raw events to figure out the nxmCall status * @private */ _handleStatusChange(event) { // for knocking case the conversation object is not yet set in the nxmCall. We know the action is initiated from us const _isEventFromMe = (this.conversation) ? this.conversation.me.id === event.from : true; const _isOutbound = this.direction === this.CALL_DIRECTION.OUTBOUND; let _handleStatusChangeMap = new Map(); _handleStatusChangeMap.set('member:joined', async () =&gt; { if (event.body.channel &amp;&amp; event.body.channel.knocking_id) { try { const stream = await this.conversation.media.enable(); this._setStatusAndEmit(this.CALL_STATUS.STARTED); return; } catch (error) { this._setStatusAndEmit(this.CALL_STATUS.FAILED); this.log.error(error); throw error; } } return Promise.resolve(); }); _handleStatusChangeMap.set('member:invited', () =&gt; { if (event.body.invited_by === null &amp;&amp; event.body.user.media &amp;&amp; event.body.user.media.audio_settings) { this._setStatusAndEmit(this.CALL_STATUS.STARTED); } return Promise.resolve(); }); _handleStatusChangeMap.set('rtc:hangup', () =&gt; { if (this.status === this.CALL_STATUS.ANSWERED) { this._setStatusAndEmit(this.CALL_STATUS.COMPLETED); return Promise.resolve(); } else { if (_isEventFromMe &amp;&amp; _isOutbound || !_isEventFromMe &amp;&amp; !_isOutbound) { this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED); return Promise.resolve(); } else { this._setStatusAndEmit(this.CALL_STATUS.REJECTED); return Promise.resolve(); } } }); _handleStatusChangeMap.set('member:left', () =&gt; { if (!event.body.timestamp.hasOwnProperty('joined') &amp;&amp; this.status !== this.CALL_STATUS.ANSWERED) { if (_isEventFromMe &amp;&amp; _isOutbound || !_isEventFromMe &amp;&amp; !_isOutbound) { this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED); return Promise.resolve(); } else { this._setStatusAndEmit(this.CALL_STATUS.REJECTED); return Promise.resolve(); } } }); _handleStatusChangeMap.set('member:media', () =&gt; { if (this.status !== this.CALL_STATUS.ANSWERED &amp;&amp; event.body.audio) { if (!_isEventFromMe || !_isOutbound) { this._setStatusAndEmit(this.CALL_STATUS.ANSWERED); } if (_isEventFromMe &amp;&amp; event.body.channel) { this.id = event.body.channel.id; } } return Promise.resolve(); }); _handleStatusChangeMap.set('sip:ringing', () =&gt; { if (this.status !== this.CALL_STATUS.RINGING) { this._setStatusAndEmit(this.CALL_STATUS.RINGING); } return Promise.resolve(); }); _handleStatusChangeMap.set('sip:hangup', () =&gt; { switch (event.body.reason.sip_code) { case 486: this._setStatusAndEmit(this.CALL_STATUS.BUSY); break; case 487: this._setStatusAndEmit(this.CALL_STATUS.TIMEOUT); break; case 403: this._setStatusAndEmit(this.CALL_STATUS.FAILED); break; } return Promise.resolve(); }); _handleStatusChangeMap.set('knocking:delete:success', () =&gt; { this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED); return Promise.resolve(); }); if (_handleStatusChangeMap.has(event.type)) { return _handleStatusChangeMap.get(event.type).call(this); } } /** * Set the nxmCall.status and emit a call:status:changed event * * @param {NXMCall.CALL_STATUS} this.CALL_STATUS the canxmCallll status to set * @emits Application#call:status:changed * @private */ _setStatusAndEmit(status) { if (!this._isValidStatusTransition(status)) { this.log.warn(`status attempt switch from ${this.status} to ${status}`); return; } this.status = status; this.application.emit('call:status:changed', this); } /** * Answers an incoming nxmCall * Join the conversation that you are invited * Create autoplay Audio object * * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true) * @returns {Promise&lt;Audio&gt;} */ async answer(autoPlayAudio = true) { if (this.conversation) { try { await this.conversation.join(); return await this.conversation.media.enable({ autoPlayAudio }); } catch (error) { this._setStatusAndEmit(this.CALL_STATUS.FAILED); this.log.error(error); throw error; } } else { throw new nexmoClientError_1.NexmoClientError('error:call:answer'); } } /** * Trigger the nxmCall flow for the input users. * Create a conversation with prefix name \"CALL_\" * and invite all the users. * If at least one user is successfully invited, enable the audio. * * @param {string[]} usernames the usernames of the users to call * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true) * @returns {Promise[]} an array of the invite promises for the provided usernames * @private */ createCall(usernames, autoPlayAudio = true) { if (!usernames || !Array.isArray(usernames) || usernames.length === 0) { return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params')); } return this.application.newConversationAndJoin({ display_name: 'CALL_' + this.application.me.name + '_' + usernames.join('_').replace(' ', '') }) .then((conversation) =&gt; { this.from = conversation.me; this.successful_invited_members = new Map(); const invites = usernames.map((username) =&gt; { // check all invites, if at least one is resolved enable audio // we need to catch rejections to allow all the chain to go through (all invites) // we then catch-reject a promise so that the errors are passing through the end of the chain return conversation.inviteWithAudio({ user_name: username }) .then((member) =&gt; { this.successful_invited_members.set(member.id, member); return Promise.resolve(member); }) .catch((error) =&gt; { this.log.error(error); // resolve the error to allow the promise.all to collect // and return all the promises return Promise.resolve(error); }); }); // helper function to process in Promise.all() the failed invites too const process_invites = () =&gt; { if (this.successful_invited_members.size &gt; 0) { return conversation.media.enable({ audio: { muted: false, earmuffed: false }, autoPlayAudio }).then((stream) =&gt; { this.application.calls.set(conversation.id, this); return Promise.resolve(invites); }); } else { return Promise.reject(invites); } }; // we need to continue the invites even if one fails, // in process_invites we do the check if at least one was successful return Promise.all(invites).then(() =&gt; { this._setupConversationObject(conversation); return process_invites(); }); }).catch((error) =&gt; { this.log.error(error); this._setStatusAndEmit(this.CALL_STATUS.FAILED); return Promise.reject(error); }); } /** * Trigger the nxmCall flow for the phone call. * Create a knocking event * * @param {string} user the phone number or the username to call * @param {string} type the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\") * @returns {Promise} * @private */ async createServerCall(user, type) { const to = { type }; if (type === 'phone') { to.number = user; } else { to.user = user; } // Add client_ref to the call draft list and request const client_ref = utils_1.default.allocateUUID(); this.client_ref = client_ref; this.application._call_draft_list.set(client_ref, this); try { return await this.application.session.sendNetworkRequest({ type: 'POST', path: 'knocking', data: { channel: { type: 'app', from: { type: 'app' }, to }, client_ref } }); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Hangs up the nxmCall * * If there is a knocking active, do a knocking:delete * otherwise * Leave from the conversation * Disable the audio * * @param {object} [reason] the reason for hanging up the nxmCall * @param {string} [reason.reason_code] the code of the reason * @param {string} [reason.reason_text] the description of the reason * @returns {Promise} */ hangUp(reason) { let disable_promise = []; if (this.conversation) { disable_promise.push(this.conversation.media.disable()); } return Promise.all(disable_promise).finally(() =&gt; { if (!this.knocking_id &amp;&amp; this.conversation) { return this.conversation.leave(reason); } else { return new Promise((resolve, reject) =&gt; { let path = `knocking/${this.knocking_id}`; if (reason) { let params = new URLSearchParams(); Object.keys(reason).forEach((key) =&gt; { params.append(key, reason[key]); }); path += `?${params.toString()}`; } this.application.session.sendNetworkRequest({ type: 'DELETE', path }).then((response) =&gt; { const nxmCall = this.application._call_draft_list.get(this.client_ref); nxmCall._handleStatusChange(response); this.application._call_draft_list.delete(this.client_ref); resolve(response); }).catch((error) =&gt; { // Don't switch yet to fail status, it could be an expected race between knocking:delete and conversation.leave if (!this.conversation) { this.log.debug('Problem cancelling the call: Knocking cancel failed and Conversation. Leave not available'); resolve(); } else { this.conversation.leave(reason).then(resolve).catch(reject); this.log.error(new nexmoClientError_1.NexmoApiError(error)); } }); }); } }); } /** * Rejects an incoming nxmCall * Leave from the conversation that you are invited * * @param {object} [reason] the reason for rejecting the nxmCall * @param {string} [reason.reason_code] the code of the reason * @param {string} [reason.reason_text] the description of the reason * @returns {Promise} */ reject(reason) { if (this.conversation) { return this.conversation.leave(reason); } else { return Promise.reject(new nexmoClientError_1.NexmoClientError('error:call:reject')); } } } exports.default = NXMCall; module.exports = NXMCall; × Search results Close "},"modules_errors_emitter.js.html":{"id":"modules_errors_emitter.js.html","title":"Source: modules/errors_emitter.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: modules/errors_emitter.js 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Errors Emitter * * Copyright (c) Nexmo Inc. */ const getLogger = require('loglevel').getLogger; const nexmoClientError_1 = require(\"../nexmoClientError\"); /** * Class that can emit errors via any emitter passed to it. * @class ErrorsEmitter * @param {Emitter} emitter - Any event emitter that implements \"emit\" and \"releaseGroup\". Basically object that is mixed with Wildemitter. * @property {string} LISTENER_GROUP='NXM-errors' - the group this emitter will register * @emits Emitter#NXM-errors * @private */ /** * Application listening for joins. * * @event Application#NXM-errors * * @property {NexmoClientError} error * * @example &lt;caption&gt;listen for errors&lt;/caption&gt; * application.on('*', 'NXM-errors', (error) =&gt; { * console.log('Error thrown with type ' + error.type); * }); * @example &lt;caption&gt;Update the token on expired-token error&lt;/caption&gt; * application.on('system:error:expired-token', 'NXM-errors', (error) =&gt; { * console.log('token expired'); * application.updateToken(&lt;token&gt;); * }); */ class ErrorsEmitter { constructor(emitter) { this.log = getLogger(this.constructor.name); if (!emitter) { throw new nexmoClientError_1.NexmoClientError('no emitter object passed for the Error Emitter'); } this.emitter = emitter; this.LISTENER_GROUP = 'NXM-errors'; } /** * Detect if the param.type includes error and emit that payload in the LISTENER_GROUP * @param param - the payload to forward in the LISTENER_GROUP * @param param.type - the type of the event to check if it's an error */ emitResponseIfError(param) { if (this._isTypeError(param.type)) { return this.emitter.emit(param.type, this.LISTENER_GROUP, param); } return; } /** * Release Group on the registered emitter (using the namespace LISTENER_GROUP that is set) */ cleanup() { return this.emitter.releaseGroup(this.LISTENER_GROUP); } /** * Returns true if the param includes 'error' * @param {string} type - the error type to check */ _isTypeError(param) { return param.indexOf('error') !== -1; } } exports.default = ErrorsEmitter; module.exports = ErrorsEmitter; × Search results Close "},"modules_media.js.html":{"id":"modules_media.js.html","title":"Source: modules/media.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: modules/media.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Media Object Model * * Copyright (c) Nexmo Inc. */ const TraceWS = require('./rtcstats/trace-ws'); const RTCStats = require('./rtcstats/rtcstats'); const getLogger = require('loglevel').getLogger; const nexmoClientError_1 = require(\"../nexmoClientError\"); const rtc_helper_1 = __importDefault(require(\"./rtc_helper\")); const utils_1 = __importDefault(require(\"../utils\")); const nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\")); /** * Member listening for audio stream on. * * @event Member#media:stream:on * * @property {number} payload.streamIndex the index number of this stream * @property {number} [payload.rtc_id] the rtc_id / leg_id * @property {string} [payload.remote_member_id] the id of the Member the stream belongs to * @property {string} [payload.name] the stream's display name * @property {MediaStream} payload.stream the stream that is activated * @property {boolean} [payload.audio_mute] if the audio is muted */ /** * WebRTC Media class * @class Media * @property {Application} application The parent application object * @property {Conversation} parentConversation the conversation object this media instance belongs to * @property {number} parentConversation.streamIndex the latest index of the streams, updated in each new peer offer * @property {object[]} rtcObjects data related to the rtc connection * @property {string} rtcObjects.rtc_id the rtc_id * @property {PeerConnection} rtcObjects.pc the current PeerConnection object * @property {Stream} rtcObjects.stream the stream of the specific rtc_id * @property {string} [rtcObjects.type] audio the type of the stream * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute) * @emits Application#rtcstats:report * @emits Member#media:stream:on */ class Media { constructor(conversation) { this.log = getLogger(this.constructor.name); if (conversation) { this.rtcHelper = new rtc_helper_1.default(); this.application = conversation.application; this.application.activeStreams = this.application.activeStreams || []; this._eventsQueue = []; this.parentConversation = conversation; this.rtcObjects = {}; this.streamIndex = 0; this.rtcstats_conf = {}; this.rtcStats = null; if (this.application.session.config &amp;&amp; this.application.session.config.rtcstats) { this.rtcstats_conf = { emit_events: this.application.session.config.rtcstats.emit_events, ws_url: this.application.session.config.rtcstats.ws_url }; } if (this.rtcstats_conf.emit_events) { this._initStatsReporting(); } } else { this.log.warn('No conversation object in Media'); } } _attachEndingEventHandlers() { this.log.debug('attaching leave listeners in media for ' + this.parentConversation.id); this.parentConversation.on('rtc:hangup', (event) =&gt; { const member = this.parentConversation.members.get(event.from); if (member.user.id === this.application.me.id &amp;&amp; (this.application.activeStreams.length)) { this._cleanMediaProperties(); } // terminate peer connection stream in case of a transfer if (member.user.id === this.application.me.id &amp;&amp; member.transferred_from) { member.transferred_from.media._cleanMediaProperties(); } }); } /** * Application listening for RTC stats. * * @event Application#rtcstats:report * * @property {number} MOS - the calculated MOS score * @property {Object} report - the stats report from WebRTC | when the call has ended this is null, see the mos_report for final MOS summary * @property {Conversation} Conversation - the conversation the report belongs to * @property {Object} mos_report - a report for the MOS values * @property {string} mos_report.min - the minimum MOS value during the stream * @property {string} mos_report.max - the maximum MOS value during the stream * @property {string} mos_report.last - the last MOS value during the stream * @property {string} mos_report.average - the average MOS value during the stream * * @example &lt;caption&gt;listening for quality mos score&lt;/caption&gt; * application.on(\"rtcstats:report\",(mos, report, conversation, mos_report) =&gt; { * console.log(\"call quality (MOS)\", mos); * if (mos_report) { * console.log('mos_report', mos_report); * } * }); */ _enableCallStats(pc) { this.application.session.callstats.addNewFabric(pc, this.parentConversation.me.id, 'audio', this.parentConversation.id); } /** * Switch on the rtcStat reporting to the websocket connection and events * @param ws_url * @private */ _enableStatsReporting(ws_url) { this.application.session.config.rtcstats.ws_url = ws_url; this.rtcstats_conf.ws_url = ws_url; this._initStatsReporting(); } /** * Switch on the rtc stats emit events * @private */ _enableStatsEvents() { this.application.session.config.rtcstats.emit_events = true; this.rtcstats_conf.emit_events = true; this._initStatsEvents(); } _initStatsReporting() { if (!this.rtcHelper.isNode() &amp;&amp; !this.rtcStats &amp;&amp; this.application.session.config.rtcstats.ws_url) { this.rtcStats_wsConnection = new TraceWS(); this.rtcStats = new RTCStats(this.rtcStats_wsConnection.trace, false, // isCallback 1000, // interval at which getStats will be polled, [''] // RTCPeerConnection prefixes to wrap. ); this.rtcStats_wsConnection.init({ rtcstatsUri: this.application.session.config.rtcstats.ws_url }); } } _initStatsEvents() { if (!this.rtcHelper.isNode() &amp;&amp; !this.rtcStats) { const emit_event = (type, mos, report, mos_report) =&gt; { if (type === 'mos') { if (mos) { this.application.emit('rtcstats:report', mos, report, this.parentConversation); } } else if (type === 'mos_report') { this.application.emit('rtcstats:report', mos, null, this.parentConversation, mos_report); } }; this.rtcStats = new RTCStats(emit_event, true, // isCallback 1000, // interval at which getStats will be polled, [''] // RTCPeerConnection prefixes to wrap. ); } } /** * Switch off the rtcStat reporting * @private */ _disableStatsReporting() { this.application.session.config.rtcstats.ws_url = ''; this.rtcstats_conf.ws_url = ''; this.rtcStats_wsConnection.disable(); delete this.rtcStats; } /** * Switch off the rtcStat events * @private */ _disableStatsEvents() { this.application.session.config.rtcstats.emit_events = false; this.rtcstats_conf.emit_events = false; this.rtcStats.disable(); delete this.rtcStats; } /** * Handles the enabling of audio only stream with rtc:new * @private */ _handleAudio(params = {}) { return new Promise((resolve, reject) =&gt; { const onClientError = (error) =&gt; { reject(new nexmoClientError_1.NexmoClientError(error)); }; const streamIndex = this.streamIndex; this.streamIndex++; this.rtcHelper.getUserAudio(params.audioConstraints) .then((localStream) =&gt; { const pc_config = { 'iceTransportPolicy': 'all', 'bundlePolicy': 'balanced', 'rtcpMuxPolicy': 'require', 'iceCandidatePoolSize': '0' }; if (this.application.session.config &amp;&amp; this.application.session.config.iceServers) { pc_config.iceServers = this.application.session.config.iceServers; } const pc = this.rtcHelper.createRTCPeerConnection(pc_config); pc.trace('conversation_id', this.parentConversation.id); pc.trace('member_id', this.parentConversation.me.id); if (this.application.session.config.callstats &amp;&amp; this.application.session.config.callstats.enabled) { this._enableCallStats(pc); } this.pc = pc; pc.ontrack = (evt) =&gt; { this.application.activeStreams.push(evt.streams[0]); this.parentConversation.me.emit('media:stream:on', { pc: this.pc, stream: evt.streams[0], type: 'audio', streamIndex }); resolve(evt.streams[0]); }; pc.addStream(localStream); pc.onnegotiationneeded = () =&gt; { pc.createOffer() .then((offer) =&gt; { return pc.setLocalDescription(offer); }).catch(onClientError); }; pc.oniceconnectionstatechange = (connection_event) =&gt; { switch (pc.iceConnectionState) { // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState case 'disconnected': this.log.warn('One or more transports is disconnected', pc.iceConnectionState); break; case 'failed': onClientError(connection_event); this.log.warn('One or more transports has terminated unexpectedly or in an error', connection_event); break; default: this.log.info('The ice connection status changed', pc.iceConnectionState); break; } }; const do_gatherDone = () =&gt; { if (!this.pc) { return; } this.log.debug(this.pc.localDescription.sdp); this.application.session.sendNetworkRequest({ type: \"POST\", path: `conversations/${this.parentConversation.id}/rtc`, data: { from: this.parentConversation.me.id, body: { offer: this.pc.localDescription } } }) .then((response) =&gt; { const rtc_id = response.rtc_id; pc.trace(\"rtc_id\", rtc_id); this.rtcObjects[rtc_id] = { rtc_id, pc, stream: localStream, type: \"audio\", streamIndex }; }) .catch((error) =&gt; { reject(new nexmoClientError_1.NexmoApiError(error)); }); }; let gatheringTimer = null; let rtc_sent = false; if (this.application.session.config.iceGatherOnlyOneCandidate) { pc.onicecandidate = (event) =&gt; { if (event.candidate &amp;&amp; !rtc_sent) { rtc_sent = true; return do_gatherDone(); } }; } else { pc.onicegatheringstatechange = () =&gt; { console.log({ pc }, pc.iceGatheringState); switch (pc.iceGatheringState) { case 'new': this.log.info('ice gathering new'); break; case 'complete': window.clearTimeout(gatheringTimer); gatheringTimer = null; if (!rtc_sent) { do_gatherDone(); } this.log.info('ice gathering complete'); break; case 'gathering': gatheringTimer = setTimeout(() =&gt; { do_gatherDone(); rtc_sent = true; }, 2000); this.log.info('ice gathering gathering'); break; } }; } }) .then(() =&gt; { // We want to be able to handle these events, for this member, before they get propagated out this.parentConversation.once('rtc:answer', (event) =&gt; { if (!this.pc) { this.log.warn('RTC: received an answer too late'); return; } this.pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: event.body.answer }), () =&gt; { this.log.info('remote description is set'); }, onClientError); }); this._attachEndingEventHandlers(); }) .catch((error) =&gt; { reject(new nexmoClientError_1.NexmoClientError(error)); }); }); } _deleteMemberMedia(member) { this._closeStream(member.stream); member.pc.close(); } _findRtcObjectByType(type) { return Object.values(this.rtcObjects).find((rtcObject) =&gt; rtcObject.type === type); } _closeStream(stream) { stream.getTracks().forEach((track) =&gt; { track.stop(); }); } async _cleanConversationProperties() { await Promise.resolve(); if (this.pc) { this.pc.close(); } // stop active stream delete this.pc; this.rtcStats = null; this.application.activeStreams = []; this.listeningToRtcEvent = false; } /** * Cleans up the user's media before leaving the conversation */ _cleanMediaProperties() { if (this.pc) { this.pc.close(); } if (this.rtcObjects) { for (const leg_id in this.rtcObjects) { this._closeStream(this.rtcObjects[leg_id].stream); } } delete this.pc; this.rtcStats = null; this.application.activeStreams = []; this.rtcObjects = {}; this.listeningToRtcEvent = false; } async _disableLeg(leg_id) { const csRequestPromise = new Promise((resolve, reject) =&gt; { this.application.session.sendNetworkRequest({ type: 'DELETE', path: `conversations/${this.parentConversation.id}/rtc/${leg_id}?from=${this.parentConversation.me.id}&amp;originating_session=${this.application.session.session_id}`, version: 'beta2' }).then((response) =&gt; { resolve('rtc:terminate:success'); }).catch((error) =&gt; { reject(new nexmoClientError_1.NexmoApiError(error)); }); }); const closeResourcesPromise = Promise.resolve().then(() =&gt; { if (this.rtcObjects[leg_id].pc) { this.rtcObjects[leg_id].pc.close(); } if (this.rtcObjects[leg_id].stream) { this._closeStream(this.rtcObjects[leg_id].stream); } }); try { await Promise.all([csRequestPromise, closeResourcesPromise]); this.parentConversation.me.emit('media:stream:off', this.rtcObjects[leg_id].streamIndex); delete this.rtcObjects[leg_id]; return 'rtc:terminate:success'; } catch (error) { throw error; } } _enableMediaTracks(tracks, enabled) { tracks.forEach((mediaTrack) =&gt; { mediaTrack.enabled = enabled; }); } /** * Send a mute request with the rtc_id and enable/disable the tracks * If the mute request fails revert the changes in the tracks * @private */ async _setMediaTracksAndMute(rtc_id, tracks, mute, mediaType) { this._enableMediaTracks(tracks, !mute); try { return await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.parentConversation.id}/events`, data: { type: mediaType, to: this.parentConversation.me.id, from: this.parentConversation.me.id, body: { rtc_id } } }); } catch (error) { this._enableMediaTracks(tracks, mute); throw new nexmoClientError_1.NexmoApiError(error); } } /** * Replaces the stream's audio tracks currently being used as the sender's sources with a new one * @param {object} constraints - audio constraints * @param {string} type - rtc object type * @param {object} [constraints.audio] - set audio constraints - { deviceId: { exact: microphoneId } } * @returns {Promise&lt;MediaStream&gt;} - Returns the new stream. * @example &lt;caption&gt;Update the stream currently being used with a new one&lt;/caption&gt; */ updateAudioConstraints(constraints = {}) { let rtcObjectByType = this._findRtcObjectByType('audio'); if (rtcObjectByType &amp;&amp; rtcObjectByType.pc) { return this.rtcHelper.getUserAudio(constraints).then((localStream) =&gt; { localStream.getTracks().forEach((track) =&gt; { const sender = rtcObjectByType.pc.getSenders().find((s) =&gt; s.track.kind === track.kind); if (sender) { track.enabled = sender.track.enabled; sender.replaceTrack(track); } }); this._closeStream(rtcObjectByType.stream); rtcObjectByType.stream = localStream; return localStream; }).catch((error) =&gt; { return error; }); } else { return Promise.reject(new nexmoClientError_1.NexmoApiError('error:media:stream:not-found')); } } /** * Mute our member * * @param {boolean} [mute=false] true for mute, false for unmute * @param {number} [streamIndex] stream id to set - if it's not set all streams will be muted * @example &lt;caption&gt;Mute audio stream in conversation&lt;/caption&gt; * media.mute(true) */ mute(mute = false, streamIndex = null) { const state = mute ? 'on' : 'off'; const audioType = 'audio:mute:' + state; let promises = []; let muteObjects = {}; if (streamIndex !== null) { muteObjects[0] = Object.values(this.rtcObjects).find(((rtcObj) =&gt; rtcObj.streamIndex === streamIndex)); if (!muteObjects[0]) { throw new nexmoClientError_1.NexmoClientError('error:media:stream:not-found'); } } else { muteObjects = this.rtcObjects; } Object.values(muteObjects).forEach((rtcObject) =&gt; { const audioTracks = rtcObject.stream.getAudioTracks(); const audioPromise = this._setMediaTracksAndMute(rtcObject.rtc_id, audioTracks, mute, audioType); promises.push(audioPromise); }); return Promise.all(promises); } /** * Earmuff our member * * @param {boolean} [params] * * @returns {Promise} * @private */ async earmuff(earmuff) { try { if (this.me === null) { throw new nexmoClientError_1.NexmoClientError('error:self'); } else { let type = 'audio:earmuff:off'; if (earmuff) { type = 'audio:earmuff:on'; } const { response } = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.parentConversation.id}/events`, data: { type, to: this.parentConversation.me.id } }); return response; } } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Enable media participation in the conversation for this application (requires WebRTC) * @param {object} params - rtc params * @param {string} params.label - Label is an application defined tag, eg. ‘fullscreen’ * @param {object} [params.audio=true] - audio enablement mode. possible values \"both\", \"send_only\", \"receive_only\", \"none\", true or false * @param {object} [params.autoPlayAudio=false] - attach the audio stream automatically to start playing after enable media (default false) * @returns {Promise&lt;MediaStream&gt;} * @example &lt;caption&gt;Enable media in this conversation&lt;/caption&gt; * function enable() { * conversation.media.enable() * .then((stream) =&gt; { * const media = document.createElement(\"audio\"); * const source = document.createElement(\"source\"); * const media_div = document.createElement(\"div\"); * media.appendChild(source); * media_div.appendChild(media); * document.insertBefore(media_div); * // Older browsers may not have srcObject * if (\"srcObject\" in media) { * media.srcObject = stream; * } else { * // Avoid using this in new browsers, as it is going away. * media.src = window.URL.createObjectURL(stream); * } * media.onloadedmetadata = (e) =&gt; { * media.play(); * }; * * }).catch((error) =&gt; { * console.log(error); * }); * } * * * **/ async enable(params) { try { if (this.parentConversation.me === null) { throw new nexmoClientError_1.NexmoClientError('error:self'); } else { // this needs to happen soon before we use pc.trace // ps.trace is injected in rtcstats module if (this.rtcstats_conf.emit_events) { this._initStatsEvents(); } const stream = await this._handleAudio(params); // attach the audio stream automatically to start playing let autoPlayAudio = (params &amp;&amp; (params.autoPlayAudio || params.autoPlayAudio === undefined)) ? true : false; if (!params || autoPlayAudio) { this.rtcHelper._playAudioStream(stream); } return stream; } } catch (error) { throw error; } } /** * Disable media participation in the conversation for this application * if RtcStats MOS is enabled, a final report will be available in * NexmoClient#rtcstats:report * @returns {Promise} * @example * * function disable() { * conversation.media.disable() * .then((response) =&gt; { * }).catch((error) =&gt; { * console.log(error); * }); * } * **/ disable() { let promises = []; promises.push(this._cleanConversationProperties()); for (const leg_id in this.rtcObjects) { promises.push(this._disableLeg(leg_id)); } return Promise.all(promises); } /** * Play a voice text in a conversation * @param {object} params * @param {string} params.text - the text to say in the conversation * @param {string} params.voice_name - * @param {number} params.level - [0] - * @param {boolean} params.queue - * @param {boolean} params.loop - * * @returns {Promise&lt;NXMEvent&gt;} * @example * conversation.media.sayText({text:'hi'}); **/ async sayText(params) { try { const response = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.parentConversation.id}/events`, data: { type: 'audio:say', cid: this.parentConversation.id, from: this.parentConversation.me.id, body: { text: params.text, voice_name: params.voice_name || 'Amy', level: params.level || 1, queue: params.queue || true, loop: params.loop || 1, ssml: params.ssml || false } } }); return new nxmEvent_1.default(this.conversation, response); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Send DTMF in a conversation * @param {string} digit - the DTMF digit(s) to send * * @returns {Promise&lt;NXMEvent&gt;} * @example * conversation.media.sendDTMF('digit'); **/ async sendDTMF(digit) { try { if (!utils_1.default.validateDTMF(digit)) { throw new nexmoClientError_1.NexmoClientError('error:audio:dtmf:invalid-digit'); } const response = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.parentConversation.id}/events`, data: { type: 'audio:dtmf', from: this.parentConversation.me.id, body: { digit } } }); const placeholder_event = { body: { digit, dtmf_id: '' }, cid: this.parentConversation.id, from: this.parentConversation.me.id, id: response.id, timestamp: response.timestamp, type: 'audio:dtmf' }; const dtmfEvent = new nxmEvent_1.default(this.parentConversation, placeholder_event); this.parentConversation.events.set(placeholder_event.id, dtmfEvent); return dtmfEvent; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Play an audio stream in a conversation * @returns {Promise&lt;NXMEvent&gt;} */ async playStream(params) { try { const response = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.parentConversation.id}/events`, data: { type: 'audio:play', body: params } }); return new nxmEvent_1.default(this.parentConversation, response); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Send start ringing event * @returns {Promise&lt;NXMEvent&gt;} * @example * Send ringing event * function startRinging() { * conversation.media.startRinging() * .then((response) =&gt; { * }).catch((error) =&gt; { * console.log(error); * }); * } * * conversation.on('audio:ringing:start', (data) =&gt; { * console.log(\"ringing\"); * }); */ async startRinging() { try { const response = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.parentConversation.id}/events`, data: { type: 'audio:ringing:start', from: this.parentConversation.me.id, body: {} } }); return new nxmEvent_1.default(this.parentConversation, response); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Send stop ringing event * @returns {Promise&lt;NXMEvent&gt;} * @example * Send ringing event * function stopRinging() { * conversation.media.stopRinging() * .then((response) =&gt; { * }).catch((error) =&gt; { * console.log(error); * }); * } * * conversation.on('audio:ringing:stop', (data) =&gt; { * console.log(\"ringing stopped\"); * } */ async stopRinging() { try { const response = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.parentConversation.id}/events`, data: { type: 'audio:ringing:stop', from: this.parentConversation.me.id, body: {} } }); return new nxmEvent_1.default(this.parentConversation, response); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } } exports.default = Media; module.exports = Media; × Search results Close "},"conversation.js.html":{"id":"conversation.js.html","title":"Source: conversation.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: conversation.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Conversation Object Model * * Copyright (c) Nexmo Inc. */ const WildEmitter = require('wildemitter'); const getLogger = require('loglevel').getLogger; const nexmoClientError_1 = require(\"./nexmoClientError\"); const member_1 = __importDefault(require(\"./member\")); const nxmEvent_1 = __importDefault(require(\"./events/nxmEvent\")); const text_event_1 = __importDefault(require(\"./events/text_event\")); const media_1 = __importDefault(require(\"./modules/media\")); const conversation_events_1 = __importDefault(require(\"./handlers/conversation_events\")); const utils_1 = __importDefault(require(\"./utils\")); const page_config_1 = __importDefault(require(\"./pages/page_config\")); const events_page_1 = __importDefault(require(\"./pages/events_page\")); /** * A single conversation Object. * @class Conversation * @property {Member} me - my Member object that belongs to this conversation * @property {Application} application - the parent Application * @property {string} name - the name of the Conversation (unique) * @property {string} [display_name] - the display_name of the Conversation * @property {Map&lt;string, Member&gt;} [members] - the members of the Conversation keyed by a member's id * @property {Map&lt;string, NXMEvent&gt;} [events] - the events of the Conversation keyed by an event's id * @property {number} [sequence_number] - the last event id */ class Conversation { constructor(application, params) { this.log = getLogger(this.constructor.name); this.application = application; this.id = null; this.name = null; this.display_name = null; this.timestamp = null; this.members = new Map(); this.events = new Map(); this.sequence_number = 0; this.pageConfig = new page_config_1.default(((this.application.session || {}).config || {}).events_page_config); this.events_page_last = null; this.conversationEventHandler = new conversation_events_1.default(application, this); this.media = new media_1.default(this); /** * A Member Object representing the current user. * Only set if the user is or has been a member of the Conversation, * otherwise the value will be `null`. * @type Member */ this.me = null; // We are not in the conversation ourselves by default // Map the params (which includes the id) this._updateObjectInstance(params); WildEmitter.mixin(Conversation); } /** Update Conversation object params * @property {object} params the params to update * @private */ _updateObjectInstance(params) { for (let key in params) { switch (key) { case 'id': this.id = params.id; break; case 'name': this.name = params.name; break; case 'display_name': this.display_name = params.display_name; break; case 'members': // update the conversation javascript object // CASE 1 conversations:get:success, // PATCH this responds with member[0].user_id and name // Iterate the list params.members.map((m) =&gt; { if (this.members.has(m.member_id)) { this.members.get(m.member_id)._normalise(m); if (m.user_id === this.application.me.id &amp;&amp; m.state !== 'LEFT') { this.me = this.members.get(m.member_id); this.members.set(this.me.id, this.me); } } else { const member = new member_1.default(this, m); if (m.user_id === this.application.me.id &amp;&amp; m.state !== 'LEFT') { this.me = member; } this.members.set(member.id, member); } }); break; case 'timestamp': this.timestamp = params.timestamp; break; case 'sequence_number': this.sequence_number = params.sequence_number; break; case 'member_id': // filter needed params to create the object // the conversation list gives us the member_id to prepare the member/this object const object_params = { id: params.member_id, state: params.state, user: this.application.me }; // update the member object or create a new instance if (this.members.has(params.member_id)) { const member_object = this.members.get(params.member_id); Object.assign(member_object, object_params); } else { const member = new member_1.default(this, object_params); this.me = member; this.members.set(member.id, member); } break; } } } /** * Join the given user to this conversation, will typically use this to join * ourselves to a conversation we create. * Accept an invitation if our member has state INVITED and no user_id / user_name is given * * @param {object} [params = this.application.me.id] The user to join (defaults to this) * @param {string} params.user_name the user_name of the user to join * @param {string} params.user_id the user_id of the user to join * @returns {Promise&lt;Member&gt;} * * @example &lt;caption&gt;join a user to a conversation&lt;/caption&gt; * * conversation.join().then((member) =&gt; { * console.log(\"joined as member: \", member) * }) */ async join(params) { const request_body = {}; const _createDefaultValues = (params) =&gt; { if (params) { if (params.user_id) { request_body.user_id = params.user_id; } if (params.user_name) { request_body.user_name = params.user_name; } } else { if (this.me &amp;&amp; this.me.id &amp;&amp; this.me.state === 'INVITED') { request_body.member_id = this.me.id; } request_body.user_name = this.application.me.name; request_body.user_id = this.application.me.id; } return request_body; }; try { let data = _createDefaultValues(params); data.action = 'join'; data.channel = { type: 'app' }; const response = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/members`, data }); const member = new member_1.default(this, response); if (response.user_id === this.application.me.id) { this.me = member; } this.members.set(member.id, member); // use case where between the time we got the conversation and the time we finished joining // the conversation object changed. this.application.getConversation(this.id); return member; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Delete a conversation * @returns {Promise} * @example &lt;caption&gt;delete the conversation&lt;/caption&gt; * * conversation.del().then(() =&gt; { * console.log(\"conversation deleted\"); * }) */ async del() { try { const response = await this.application.session.sendNetworkRequest({ type: 'DELETE', path: `conversations/${this.id}` }); this.application.conversations.delete(this.id); return response; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Delete an NXMEvent (e.g. Text) * @param {NXMEvent} event * @returns {Promise} * */ deleteEvent(event) { return event.del(); } /** * Invite the given user (id or name) to this conversation * @param {Member} params * @param {string} [params.id or username] - the id or the username of the user to invite * * @returns {Promise&lt;Member&gt;} * * @example &lt;caption&gt;invite a user to a conversation&lt;/caption&gt; * const user_id = 'user to invite'; * const user_name = 'username to invite'; * * conversation.invite({ * id: user_id, * user_name: user_name * }).then((member) =&gt; { * displayMessage(member.state + \" user: \" + user_id + \" \" + user_name); * }).catch((error) =&gt; { * console.log(error); * }); * */ async invite(params) { if (!params || (!params.id &amp;&amp; !params.user_name)) { throw new nexmoClientError_1.NexmoClientError('error:invite:missing:params'); } try { const response = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/members`, data: { action: \"invite\", ...(params.id &amp;&amp; { user_id: params.id }), ...(params.user_name &amp;&amp; { user_name: params.user_name }), member_id_inviting: this.me.id, media: params.media, channel: { from: { type: \"app\" }, leg_ids: [], leg_settings: {}, legs: [], to: { type: \"app\" }, type: \"app\" } } }); const member = new member_1.default(this, response); this.members.set(member.id, member); return member; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Invite the given user (id or name) to this conversation with media audio * @param {Member} params * @param {string} [params.id or username] - the id or the username of the user to invite * * @returns {Promise&lt;Member&gt;} * * @example &lt;caption&gt;invite a user to a conversation&lt;/caption&gt; * const user_id = 'user to invite'; * const user_name = 'username to invite'; * * conversation.inviteWithAudio({ * id: user_id, * user_name: user_name * }).then((member) =&gt; { * displayMessage(member.state + \" user: \" + user_id + \" \" + user_name); * }).catch((error) =&gt; { * console.log(error); * }); * */ inviteWithAudio(params) { if (!params || (!params.id &amp;&amp; !params.user_name)) { return Promise.reject(new nexmoClientError_1.NexmoClientError('error:invite:missing:params')); } params.media = { audio_settings: { enabled: true, muted: false, earmuffed: false } }; return this.invite(params); } /** * Leave from the conversation * @param {object} [reason] the reason for leaving the conversation * @param {string} [reason.reason_code] the code of the reason * @param {string} [reason.reason_text] the description of the reason * @returns {Promise} */ leave(reason) { return this.me.kick(reason); } /** * Send a text message to the conversation, which will be relayed to every other member of the conversation * @param {string} text - the text message to be sent * * @returns {Promise&lt;TextEvent&gt;} - the text message that was sent * * @example &lt;caption&gt; sending a text &lt;/caption&gt; * conversation.sendText(\"Hi Nexmo\").then(() =&gt; { * console.log('message was sent'); * }).catch((error)=&gt;{ * console.log('error sending the message', error); * }); * */ async sendText(text) { try { if (this.me === null) { throw new nexmoClientError_1.NexmoClientError('error:self'); } const msg = { type: 'text', cid: this.id, from: this.me.id, body: { text } }; const { id, timestamp } = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/events`, data: msg }); msg.id = id; msg.body.timestamp = timestamp; return new text_event_1.default(this, msg); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Send a custom event to the conversation * @param {object} params - params of the custom event * @param {string} type - the name of the custom event. Must not exceed 100 char length and contain only alpha numerics and '-' and '_' characters. * @param {object} body - customizable key value pairs * * @returns {Promise&lt;NXMEvent&gt;} - the custom event that was sent * * @example &lt;caption&gt; sending a custom event &lt;/caption&gt; * conversation.sendCustomEvent({ type: 'my-event', body: {}}).then(() =&gt; { * console.log('custom event was sent'); * }).catch((error)=&gt;{ * console.log('error sending the custom event', error); * }); * */ async sendCustomEvent({ type, body }) { try { if (this.me === null) { throw new nexmoClientError_1.NexmoClientError('error:self'); } else if (!type || typeof type !== 'string' || type.length &lt; 1) { throw new nexmoClientError_1.NexmoClientError('error:custom-event:invalid'); } const data = { type: `custom:${type}`, cid: this.id, from: this.me.id, body }; const { id, timestamp } = await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/events`, data }); data.id = id; data.timestamp = timestamp; return new nxmEvent_1.default(this, data); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Send an Image message to the conversation, which will be relayed to every other member of the conversation. * implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest * * @param {File} file single input file (jpeg/jpg) * @param {string} [params.quality_ratio = 100] a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image * @param {string} [params.medium_size_ratio = 50] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original * @param {string} [params.thumbnail_size_ratio = 10] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original * * @returns {Promise&lt;XMLHttpRequest&gt;} * * @example &lt;caption&gt;sending an image&lt;/caption&gt; * conversation.sendImage(fileInput.files[0]).then((imageRequest) =&gt; { * imageRequest.onabort = (e) =&gt; { * console.log(e); * console.log(\"Image:\" + e.type); * }; * imageRequest.onloadend = (e) =&gt; { * console.log(\"Image:\" + e.type); * }; * }); */ async sendImage(fileInput, params = { quality_ratio: 100, medium_size_ratio: 50, thumbnail_size_ratio: 30 }) { const formData = new FormData(); formData.append('file', fileInput); formData.append('quality_ratio', params.quality_ratio); formData.append('medium_size_ratio', params.medium_size_ratio); formData.append('thumbnail_size_ratio', params.thumbnail_size_ratio); const imageRequest = await utils_1.default.networkRequest({ type: 'POST', url: this.application.session.config.ips_url, data: formData, token: this.application.session.config.token }); imageRequest.upload.addEventListener('progress', (evt) =&gt; { if (evt.lengthComputable) { this.log.debug('uploading image ' + evt.loaded + '/' + evt.total); } }, false); imageRequest.onreadystatechange = () =&gt; { if (imageRequest.readyState === 4 &amp;&amp; imageRequest.status === 200) { try { this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/events`, data: { type: 'image', from: this.me.id, body: { representations: JSON.parse(imageRequest.responseText) } } }); this.log.info(imageRequest); } catch (error) { this.log.error(new nexmoClientError_1.NexmoApiError(error)); } } if (imageRequest.status !== 200) { this.log.error(imageRequest); } }; return imageRequest; } /** * Cancel sending an Image message to the conversation. * * @param {XMLHttpRequest} imageRequest * * @returns void * * @example &lt;caption&gt;cancel sending an image&lt;/caption&gt; * conversation.sendImage(fileInput.files[0]).then((imageRequest) =&gt; { * conversation.abortSendImage(imageRequest); * }); */ abortSendImage(imageRequest) { if (imageRequest instanceof XMLHttpRequest) { return imageRequest.abort(); } else { return new nexmoClientError_1.NexmoClientError('error:invalid:param:type'); } } async _typing(state) { const params = { activity: (state === 'on') ? 1 : 0 }; const data = { type: 'text:typing:' + state, cid: this.id, from: this.me.id, body: params }; try { await this.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/events`, data }); return `text:typing:${state}:success`; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Send start typing indication * * @returns {Promise} - resolves the promise on successful sent */ startTyping() { return this._typing('on'); } /** * Send stop typing indication * * @returns {Promise} - resolves the promise on successful sent */ stopTyping() { return this._typing('off'); } /** * Query the service to get a list of events in this conversation. * * @param {object} params configure defaults for paginated events query * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time * @param {number} params.page_size the number of resources returned in a single request list * @param {string} [params.cursor] string to access the starting point of a dataset * @param {string} [params.event_type] the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*' * * @returns {Promise&lt;EventsPage&lt;Map&lt;Events&gt;&gt;&gt;} - Populate Conversations.events. * @example &lt;caption&gt;Get Events&lt;/caption&gt; * conversation.getEvents({ event_type: 'member:*' ).then((events_page) =&gt; { * events_page.items.forEach(event =&gt; { * render(event) * }) * }); */ async getEvents(params = {}) { const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.id}/events`; // Create pageConfig if given params otherwise use default let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params); try { const response = await utils_1.default.paginationRequest(url, pageConfig, this.application.session.config.token); response.application = this.application; response.conversation = this; const events_page = new events_page_1.default(response); this.events_page_last = events_page; return events_page; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Handle and event from the cloud. * using conversationEventHandler * @param {object} event * @private */ _handleEvent(event) { if (event.type.startsWith('rtc')) { // keep the rtc events going to the application layer, we use them in media module this.emit(event.type, event); return; } this.sequence_number++; if (event.from &amp;&amp; !this.members.has(event.from)) { this.members.set(event.from, new member_1.default(this, event)); } // make sure the event_id is not a string if (event.body &amp;&amp; event.body.event_id &amp;&amp; typeof event.body.event_id === 'string') { event.body.event_id = parseInt(event.body.event_id); } const from = this.members.get(event.from); let constructed_event = this.conversationEventHandler.handleEvent(event); // Unless they are typing events, add the event to the conversation.events map if (!['text:typing:on', 'text:typing:off'].includes(event.type)) { this.events.set(constructed_event.id, constructed_event); } // For custom events remove the custom: prefix before emitting event if (event.type.startsWith('custom:')) { this.emit(constructed_event.type, from, constructed_event); return; } this.emit(event.type, from, constructed_event); } } exports.default = Conversation; module.exports = Conversation; × Search results Close "},"sdk.js.html":{"id":"sdk.js.html","title":"Source: sdk.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: sdk.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Main wrapper * * Copyright (c) Nexmo Inc. */ const WildEmitter = require('wildemitter'); const logger = require('loglevel'); const prefix = require('loglevel-plugin-prefix'); const nexmoClientError_1 = require(\"./nexmoClientError\"); const socket_io_client_1 = __importDefault(require(\"socket.io-client\")); const js_1 = __importDefault(require(\"@bugsnag/js\")); const utils_1 = __importDefault(require(\"./utils\")); const application_1 = __importDefault(require(\"./application\")); const errors_emitter_1 = __importDefault(require(\"./modules/errors_emitter\")); const user_1 = __importDefault(require(\"./user\")); prefix.reg(logger); prefix.apply(logger, { template: '[%t] %l (NXM-%n):', timestampFormatter: (date) =&gt; { return date.toTimeString().replace(/.*(\\d{2}:\\d{2}:\\d{2}).*/, '$1'); }, levelFormatter: (level) =&gt; { return level.toUpperCase(); }, nameFormatter: (name) =&gt; { return name || 'SDK'; } }); /** * The parent NexmoClient class. * * @class NexmoClient * * @param {object} params the settings to initialise the SDK * @param {Boolean} params.debug='silent' set mode to 'debug', 'info', 'warn', or 'error' for customized logging levels in the console * @param {string} params.url='nexmo_ws_url' Nexmo Conversation Websocket url, default is wss://ws.nexmo.com (wss://ws-us-1.nexmo.com for WDC, wss://ws-us-2.nexmo.com for DAL, wss://ws-eu-1.nexmo.com for LON, wss://ws-sg-1.nexmo.com for SNG) * @param {string} params.nexmo_api_url=Nexmo Conversation Api url, default is https://api.nexmo.com (https://api-us-1.nexmo.com for WDC, https://api-us-2.nexmo.com for DAL, https://api-eu-1.nexmo.com for LON, https://api-sg-1.nexmo.com for SNG) * @param {string} params.ips_url='ips_url' Nexmo IPS url for image upload, default is https://api.nexmo.com/v1/image (https://api-us-1.nexmo.com/v1/image for WDC, https://api-us-2.nexmo.com/v1/image for DAL, https://api-eu-1.nexmo.com/v1/image for LON, https://api-sg-1.nexmo.com/v1/image for SNG) * @param {string} params.path='/rtc' Nexmo Conversation Websocket url path suffix * @param {object} params.rtcstats set reporting for stream statistics (Websocket or internal event emit) * @param {string} params.rtcstats.ws_url endpoint (websocket) to send rtc stats. * @param {Boolean} params.rtcstats.emit_events=false receive rtcstats:report event * @param {object} params.socket_io configure socket.io * @param {Boolean} params.socket_io.forceNew=true configure socket.io forceNew attribute * @param {Boolean} params.socket_io.autoConnect=true socket.io autoConnect attribute * @param {Boolean} params.socket_io.reconnection=true socket.io reconnection attribute * @param {number} params.socket_io.reconnectionAttempts=5 socket.io reconnectionAttempts attribute * @param {string[]} params.socket_io.transports='websocket' socket.io transports protocols * @param {string[]} params.sync='lite' {'lite' || 'full' || 'none'} after a successful login, synchronise conversations, include events or nothing * @param {string} params.environment='production' development / production environment * @param {object} params.iceServers=[{'stun:stun.l.google.com:19302'}] iceServers for RTCPeerConnection * @param {object} params.callstats configure callstats.io integration * @param {Boolean} params.callstats.enabled=false * @param {string} params.callstats.AppID your callstats AppID * @param {string} params.callstats.AppSecret your callstats AppSecret * @param {object} params.log_reporter configure log reports for bugsnag tool * @param {Boolean} params.log_reporter.enabled=true * @param {string} params.log_reporter.bugsnag_key your bugsnag api key / defaults to Nexmo api key * @param {object} params.conversations_page_config configure paginated requests for conversations * @param {number} params.conversations_page_config.page_size=10 the number of resources returned in a single request list * @param {string} params.conversations_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time) * @param {string} params.conversations_page_config.cursor cursor parameter to access the next or previous page of a data set * @param {object} params.events_page_config configure paginated requests for events * @param {number} params.events_page_config.page_size=10 the number of resources returned in a single request list * @param {string} params.events_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time) * @param {string} params.events_page_config.event_type the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*' * @param {string} params.token the jwt token for network requests * @param {string} params.iceGatherOnlyOneCandidate=false the flag for gathering one candidate or multiple in rtc ice gathering process * * @emits NexmoClient#connecting * @emits NexmoClient#disconnect * @emits NexmoClient#error * @emits NexmoClient#ready * @emits NexmoClient#reconnect * @emits NexmoClient#reconnecting */ class NexmoClient { constructor(params) { // save an array of instances const inputParams = params || {}; this.config = { debug: 'silent', callstats: { enabled: false, AppID: '', AppSecret: '' }, log_reporter: { enabled: false, bugsnag_key: null }, environment: '@@environment', ips_url: '@@ips_url', nexmo_api_url: '@@nexmo_api_url', path: '/rtc', repository: '@@repository', socket_io: { reconnection: true, reconnectionAttempts: 5, forceNew: true, autoConnect: true, transports: ['websocket'] }, SDK_version: '@@SDK_version', sync: 'lite', url: '@@ws_url', iceServers: [{ urls: 'stun:stun.l.google.com:19302' }], rtcstats: { ws_url: '', emit_events: false }, conversations_page_config: { page_size: 10, order: 'asc', cursor: '' }, events_page_config: { page_size: 10, order: 'asc', event_type: '' }, token: null, iceGatherOnlyOneCandidate: false }; this.sessionReady = false; this.session_id = null; this.requests = {}; this.application = null; /* Definitions of log levels error: major error messages, some lost functionality warn: error messages which do not cause a functional failure info: informational messages, showing completion, progress, etc. debug: messages to help in diagnosing a problem */ if (['debug', 'info', 'warn', 'error'].includes(inputParams.debug)) { logger.setLevel(inputParams.debug); } else if (inputParams.debug === true) { logger.setLevel('debug'); } else { logger.setLevel('silent'); } this.log = logger.noConflict(); // set our config from the inputParams this.config = utils_1.default.deepMergeObj(this.config, this._sanitizeConfig(inputParams)); // inject callstats library if (this.config.callstats.enabled) { utils_1.default.injectScript('//api.callstats.io/static/callstats.min.js', () =&gt; { const callstats = document.callstats; if (typeof callstats !== 'undefined') { // eslint-disable-next-line new-cap this.callstats = new callstats(); } }); } // inject bug reporting tool if (this.config.log_reporter.enabled) { global.NXMbugsnagClient = js_1.default({ apiKey: this.config.log_reporter.bugsnag_key || utils_1.default._getBugsnagKey(), appVersion: this.config.SDK_version, releaseStage: this.config.environment }); } this._createAndSetConnection(); WildEmitter.mixin(NexmoClient); } /** * Creates and sets the socket_io connection * * @private */ _createAndSetConnection() { let connection; // Create the socket.io connection and allow multiple instances let socket_io_config = Object.assign({ path: this.config.path }, this.config.socket_io); connection = socket_io_client_1.default.connect(this.config.url, socket_io_config); this.connection = connection; /** * Ready event. * * @event NexmoClient#ready * @example &lt;caption&gt;Listen to websocket ready event &lt;/caption&gt; * rtc.on(\"ready\", () =&gt; { * console.log(\"connection ready\"); * }); */ connection.on('connect', () =&gt; { this.emit('ready'); this.sessionReady = true; this.log.info('websocket ready'); }); // Listen to socket.io events /** * Connecting event. * * @event NexmoClient#connecting * @example &lt;caption&gt;Listen to websocket connecting event &lt;/caption&gt; * rtc.on(\"connecting\", () =&gt; { * console.log(\"connecting\"); * }); */ connection.on('connecting', () =&gt; { this.emit('connecting'); this.log.info('websocket connecting'); }); /** * Disconnect event. * * @event NexmoClient#disconnect * @example &lt;caption&gt;Listen to websocket disconnect event &lt;/caption&gt; * rtc.on(\"disconnect\", () =&gt; { * console.log(\"disconnect\"); * }); */ connection.on('disconnect', () =&gt; { this.emit('disconnect'); this.log.info('websocket disconnected'); }); /** * Reconnect event. * * @event NexmoClient#reconnect * @example &lt;caption&gt;Listen to websocket reconnect event &lt;/caption&gt; * rtc.on(\"reconnect\", (retry_number) =&gt; { * console.log(\"reconnect\", retry_number); * }); */ connection.on('reconnect', (retry_number) =&gt; { this.emit('reconnect', retry_number); this.log.info('websocket reconnect'); }); /** * Reconnecting event. * * @event NexmoClient#reconnecting * @example &lt;caption&gt;Listen to websocket reconnecting event &lt;/caption&gt; * rtc.on(\"reconnecting\", (retry_number): void =&gt; { * console.log(\"reconnecting\", retry_number); * }); */ connection.on('reconnecting', (retry_number) =&gt; { this.emit('reconnecting', retry_number); this.log.info('websocket reconnecting'); }); /** * Error event. * * @event NexmoClient#error * @example &lt;caption&gt;Listen to websocket error event &lt;/caption&gt; * rtc.on(\"error\", (error) =&gt; { * console.log(\"error\", error); * }); */ connection.on('error', (error) =&gt; { this.emit('error', new nexmoClientError_1.NexmoClientError(error)); this.log.error('Socket.io reported a generic error', error); }); connection.io.on('packet', (packet) =&gt; { if (packet.type !== 2) return; if (packet.data[0] === 'echo') return; // ignore echo events const response = packet.data[1]; // Set the type of the response response.type = packet.data[0]; this.log.debug('&lt;--', response.type, response); if (response.rid in this.requests) { const callback = this.requests[response.rid].callback; delete this.requests[response.rid]; delete response.delay; if (this.errorsEmitter) { this.errorsEmitter.emitResponseIfError(response); } callback(response); } else { // This is an unsolicited event // we emit it in application level. if (this.application) { this.application._handleEvent(response); } } }); return connection; } /** * Revert any invalid params to our default * * @param {object} config the object to sanitize * @private */ _sanitizeConfig(incomingConfig) { // make sure we allow specific values for the params // Sync let sanitizedConfig = incomingConfig; if (incomingConfig.sync &amp;&amp; ['lite', 'full', 'none'].indexOf(incomingConfig.sync) === -1) { this.log.warn(`invalid param '${incomingConfig.sync}' for sync, reverting to ${this.config.sync}`); sanitizedConfig.sync = this.config.sync; } return sanitizedConfig; } /** * Conversation listening for text events. * * @event Conversation#text * * @property {Member} sender - The sender of the text * @property {TextEvent} text - The text message received * @example &lt;caption&gt;listen for text events&lt;/caption&gt; * conversation.on(\"text\",(sender, message) =&gt; { * console.log(sender,message); * // Identify your own message. * if (message.from !== conversation.me.id) * // Identify if the event corresponds to the currently open conversation. * if (message.cid === conversation.id) * }); */ /** * * Conversation listening for image events. * * @event Conversation#image * * @property {Member} sender - The sender of the image * @property {ImageEvent} image - The image message received * @example &lt;caption&gt;listen for image events&lt;/caption&gt; * conversation.on(\"image\", (sender, image) =&gt; { * console.log(sender,image); * // Identify your own imageEvent. * if (image.from !== conversation.me.id) * // Identify if the event corresponds to the currently open conversation. * if (image.cid === conversation.id) * }); */ /** * Conversation listening for deleted events. * * @event Conversation#event:delete * * @property {Member} member - the member who deleted an event * @property {NXMEvent} event - deleted event: event.id * @example &lt;caption&gt;get details about the deleted event&lt;/caption&gt; * conversation.on(\"event:delete\", (member, event) =&gt; { * console.log(event.id); * console.log(event.body.timestamp.deleted); * }); */ /** * Conversation listening for new members. * * @event Conversation#member:joined * * @property {Member} member - the member that joined * @property {NXMEvent} event - the join event * @example &lt;caption&gt;get the name of the new member&lt;/caption&gt; * conversation.on(\"member:joined\", (member, event) =&gt; { * console.log(event.id) * console.log(member.user.name+ \" joined the conversation\"); * }); */ /** * Conversation listening for members being invited. * * @event Conversation#member:invited * * @property {Member} member - the member that is invited * @property {NXMEvent} event - data regarding the receiver of the invitation * @example &lt;caption&gt;get the name of the invited member&lt;/caption&gt; * conversation.on(\"member:invited\", (member, event) =&gt; { * console.log(member.user.name + \" invited to the conversation\"); * }); */ /** * Conversation listening for members callStatus changes. * * @event Conversation#member:call:status * * @property {Member} member - the member that has left * @example &lt;caption&gt;get the callStatus of the member that changed call status&lt;/caption&gt; * conversation.on(\"member:call:status\", (member) =&gt; { * console.log(member.callStatus); * }); */ /** * Conversation listening for members leaving (kicked or left). * * @event Conversation#member:left * * @property {Member} member - the member that has left * @property {NXMEvent} event - data regarding the receiver of the invitation * @example &lt;caption&gt;get the username of the member that left&lt;/caption&gt; * conversation.on(\"member:left\", (member , event) =&gt; { * console.log(member.user.name + \" left\"); * console.log(event.body.reason); * }); */ /** * Conversation listening for members typing. * * @event Conversation#text:typing:on * * @property {Member} member - the member that started typing * @property {NXMEvent} event - the start typing event * @example &lt;caption&gt;get the username of the member that is typing&lt;/caption&gt; * conversation.on(\"text:typing:on\", (data) =&gt; { * console.log(data.name + \" is typing...\"); * }); */ /** * Conversation listening for members stopped typing. * * @event Conversation#text:typing:off * * @property {Member} member - the member that stopped typing * @property {NXMEvent} event - the stop typing event * @example &lt;caption&gt;get the username of the member that stopped typing&lt;/caption&gt; * conversation.on(\"text:typing:off\", (data) =&gt; { * console.log(data.name + \" stopped typing...\"); * }); */ /** * Conversation listening for members' seen texts. * * @event Conversation#text:seen * * @property {Member} member - the member that saw the text * @property {TextEvent} text - the text that was seen * @example &lt;caption&gt;listen for seen text events&lt;/caption&gt; * conversation.on(\"text:seen\", (data, text) =&gt; { * console.log(text); * // Check if the event belongs to this conversation * if (text.cid === conversation.id) * // Get the list of members that have seen this event * for (let member_id in text.state.seen_by) { * if (conversation.me.id !== member_id) { * console.log(conversation.members.get(member_id).name); * } * } * }); */ /** * Conversation listening for members' seen images. * @event Conversation#image:seen * * @property {Member} member - the member that saw the image * @property {ImageEvent} image - the image that was seen * @example &lt;caption&gt;listen for seen image events&lt;/caption&gt; * conversation.on(\"image:seen\", (data, image) =&gt; { * console.log(image); * // Check if the event belongs to this conversation * if (image.cid === conversation.id) * // Get the list of members that have seen this event * for (let member_id in image.state.seen_by) { * if (conversation.me.id !== member_id) { * console.log(conversation.members.get(member_id).name); * } * } * }); */ /** * Conversation listening for members media changes (audio,text) * * Change in media presence state. They are in the conversation with text or audio. * * @event Conversation#member:media * * @property {Member} member - the member object linked to this event * @property {NXMEvent} event - information about media presence state * @property {boolean} event.body.audio - is audio enabled * @example &lt;caption&gt;get every member's media change events &lt;/caption&gt; * conversation.on(\"member:media\", (from, event) =&gt; { * console.log(from.media.audio_settings.enabled); //true * console.log(event.body.media); //{\"audio_settings\": {\"enabled\": true, \"muted\": false, \"earmuffed\": false}} * }); */ /** * Conversation listening for mute on events * A member has muted their audio * * @event Conversation#audio:mute:on * * @property {Member} member - the member object linked to this event * @property {NXMEvent} event - information about the mute event */ /** * Conversation listening for mute off events * A member has unmuted their audio * * @event Conversation#audio:mute:off * * @property {Member} member - the member object linked to this event * @property {NXMEvent} event - information about the mute event */ sendRequest(request, callback) { // Add a message ID to the request and set up a listener for the reply (or error) request.tid = utils_1.default.allocateUUID(); const type = request.type; delete request.type; this.log.debug('--&gt;', type, request); this.log.info('--&gt;', type, request.tid); this.connection.emit(type, request); this.requests[request.tid] = { type: type, request: request, callback: callback }; } async sendNetworkRequest(params) { const version = params.version || 'beta'; const url = `${this.config.nexmo_api_url}/${version}/${params.path}`; if (!(params.type === 'GET' || params.type === 'DELETE')) { if (params.data) { params.data.originating_session = this.session_id; } else { params.data = { originating_session: this.session_id }; } } try { const { response } = await utils_1.default.networkRequest({ type: params.type, url, data: (params.data) ? params.data : null, token: (params.data || {}).token ? params.data.token : this.config.token || null }); return response; } catch ({ response }) { throw response; } } /** * Login to the cloud. * @param {string} token - the login token * @returns {Promise&lt;Application&gt;} - the application we logged in */ login(token) { // Create connection if needed if (typeof this.connection === 'undefined') { this._createAndSetConnection(); } // return a promise for the application return new Promise((resolve, reject) =&gt; { this.log.info(`Client-SDK Version: ${this.config.SDK_version}`); this.config.token = null; this.sendRequest({ type: 'session:login', body: { token, SDK_version: this.config.SDK_version, OS_family: 'js', OS_revision: (typeof navigator !== 'undefined') ? navigator.userAgent : (typeof window !== 'undefined') ? window.navigator.userAgent : 'Generic JS navigator' } }, (response) =&gt; { if (response.type === 'session:success') { this.session_id = response.body.id; this.config.token = this.config.nexmo_api_url.includes('npe') ? token : null; if (!this.application || (this.application.me &amp;&amp; this.application.me.id !== response.body.user_id)) { this.application = new application_1.default(this, {}); } if (!this.application.me) { this.application.me = new user_1.default(this.application, { id: response.body.user_id, name: response.body.name }); } if (!this.errorsEmitter) { this.errorsEmitter = new errors_emitter_1.default(this.application); } if (typeof (this.callstats) !== 'undefined') { const csStatsInit = (csError, csErrMsg) =&gt; { this.log.info(`Status: errCode= ${csError} errMsg= ${csErrMsg}`); }; const reportType = { inbound: 'inbound', outbound: 'outbound' }; // callback function to receive the stats const csStatsCallback = (stats) =&gt; { let ssrc; for (ssrc in stats.streams) { this.log.info('SSRC is: ', ssrc); let dataSsrc = stats.streams[ssrc]; this.log.info('SSRC Type ', dataSsrc.reportType); if (dataSsrc.reportType === reportType.outbound) { this.log.info('RTT is: ', dataSsrc.rtt); } else if (dataSsrc.reportType === reportType.inbound) { this.log.info('Inbound loss rate is: ', dataSsrc.fractionLoss); } } }; const configParams = { disableBeforeUnloadHandler: true, applicationVersion: this.config.SDK_version, disablePrecalltest: true // disables the pre-call test, it is enabled by default }; this.callstats.initialize(this.config.callstats.AppID, this.config.callstats.AppSecret, this.application.me.id, csStatsInit, csStatsCallback, configParams); } // Set Bugsnag user to application.me.id if (this.config.log_reporter.enabled) { global.NXMbugsnagClient.user = { id: this.application.me.id, name: this.application.me.name, session_id: response.body.id }; } // Store token in config this.config.token = token; if (this.config.sync !== 'none') { // Retrieve the existing conversation data for this user return this.application.getConversations().then(() =&gt; { resolve(this.application); }).catch((reason) =&gt; { reject(reason); }); } else { resolve(this.application); } } else { reject(new nexmoClientError_1.NexmoApiError(response)); } }); }); } /** * logout from the cloud. */ logout() { return new Promise((resolve, reject) =&gt; { const logoutRequest = () =&gt; { return this.sendRequest({ type: 'session:logout', body: {} }, (response) =&gt; { if (response.type === 'session:logged-out' || response.type === 'session:terminated') { this.disconnect(); delete this.errorsEmitter; delete this.application; delete this.connection; this.requests = {}; this.sessionReady = false; resolve(response); } else { reject(response); } }); }; // prepare for logout if (this.application) { let disablePromises = []; if (this.application.conversations.size) { for (let conversation of this.application.conversations.values()) { disablePromises.push(conversation.media.disable()); } } return Promise.all(disablePromises) .catch((err) =&gt; { this.log.info(err); }) .then(() =&gt; { return logoutRequest(); }); } else { return logoutRequest(); } }); } /** * Disconnect from the cloud. * */ disconnect() { return this.connection.disconnect(); } /** * Connect from the cloud. * */ connect() { return this.connection.connect(); } } exports.default = NexmoClient; module.exports = NexmoClient; × Search results Close "},"handlers_conversation_events.js.html":{"id":"handlers_conversation_events.js.html","title":"Source: handlers/conversation_events.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: handlers/conversation_events.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Conversation Events Handler * * Copyright (c) Nexmo Inc. */ const getLogger = require('loglevel').getLogger; const nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\")); const text_event_1 = __importDefault(require(\"../events/text_event\")); const image_event_1 = __importDefault(require(\"../events/image_event\")); /** * Handle Conversation Events * * @class ConversationEventsHandler * @param {Application} application * @param {Conversation} conversation * @private */ class ConversationEventHandler { constructor(application, conversation) { this.log = getLogger(this.constructor.name); this.application = application; this.conversation = conversation; this.constructed_event = null; this._handleEventMap = { 'event:delete': this._processDelete, 'image': this._processImage, 'image:delivered': this._processDelivered, 'image:seen': this._processSeen, 'member:invited': this._processMember, 'member:joined': this._processMember, 'member:left': this._processMember, 'audio:ringing:start': this._processMember, 'leg:status:update': this._processLegStatus, 'member:media': this._processMedia, 'text': this._processText, 'text:delivered': this._processDelivered, 'text:seen': this._processSeen, 'audio:mute:on': this._processMuteForMedia, 'audio:mute:off': this._processMuteForMedia }; } /** * Handle and event. * * Identify the type of the event, * create the corresponding Class instance * emit to the corresponding Objects * @param {object} event * @private */ handleEvent(event) { if (this._handleEventMap.hasOwnProperty(event.type)) { return this._handleEventMap[event.type].call(this, event) || new nxmEvent_1.default(this.conversation, event); } return new nxmEvent_1.default(this.conversation, event); } /** * Mark the requested event as delivered * use that event as constructed to update the local events' map * @param {object} event * @returns the NXMEvent that is marked as delivered * @private */ _processDelivered(event) { let event_to_mark = this.conversation.events.get(event.body.event_id); if (event_to_mark) { event_to_mark.state = event_to_mark.state || {}; event_to_mark.state.delivered_to = event_to_mark.state.delivered_to || {}; event_to_mark.state.delivered_to[event.from] = event.timestamp; return event_to_mark; } else { this.log.warn('NXMEvent not found'); return null; } } /** * Delete the requested event * empty the payload of the event (text or image) * use that event as constructed to update the local events' map * @param {object} event * @returns the deleted events * @private */ _processDelete(event) { let event_to_delete = this.conversation.events.get(event.body.event_id); if (event_to_delete) { if (event_to_delete.body.text) event_to_delete.body.text = ''; if (event_to_delete.body.representations) event_to_delete.body.representations = ''; event_to_delete.body.timestamp = { deleted: event.timestamp }; return event_to_delete; } else { this.log.warn('NXMEvent not found'); return null; } } /** * Return an ImageEvent with the corresponding image data * @param {object} event * @returns {ImageEvent} */ _processImage(event) { const imageEvent = new image_event_1.default(this.conversation, event); // Automatically send a delivery // avoid sending delivered to our own events if (this.conversation.me.id !== imageEvent.from) { imageEvent.delivered(); } return imageEvent; } /** * Handle events for member state changes (joined, invited, left) * in conversation level. * Other members are going through here too. * For .me member initial event (join, invite) use the application listener * @param {object} event * @returns {NXMEvent} * @private */ _processMember(event) { // needs to first process the call state and then alter the member if (this.application.calls.has(this.conversation.id)) { let call = this.application.calls.get(this.conversation.id); call._handleStatusChange(event); } this.conversation.members.get(event.from)._handleEvent(event); return new nxmEvent_1.default(this.conversation, event); } /** * Handle events for leg status updates in conversation level. * Other member's legs are going through here too. * @param {object} event * @returns {NXMEvent} * @private */ _processLegStatus(event) { this.conversation.members.get(event.from)._handleEvent(event); return new nxmEvent_1.default(this.conversation, event); } /** * Handle member:media events * use a call object if and the member object * @param {object} event * @private */ _processMedia(event) { this.conversation.members.get(event.from)._handleEvent(event); return null; } /** * Handle *:mute:* events * @param {object} event * @private */ _processMuteForMedia(event) { if (this.conversation.media.rtcObjects[event.body.rtc_id]) { event.streamIndex = this.conversation.media.rtcObjects[event.body.rtc_id].streamIndex; } else { this.log.warn('No audio stream was found'); } return null; } /** * Mark the requested event as seen * use that event as constructed to update the local Events' map * @param {object} event * @private */ _processSeen(event) { let event_to_mark = this.conversation.events.get(event.body.event_id); if (event_to_mark) { event_to_mark.state = event_to_mark.state || {}; event_to_mark.state.seen_by = event_to_mark.state.seen_by || {}; event_to_mark.state.seen_by[event.from] = event.timestamp; return event_to_mark; } else { this.log.warn('NXMEvent not found'); return null; } } /** * Create the TextEvent object and trigger .delivered() * @param {object} event * @private */ _processText(event) { const textEvent = new text_event_1.default(this.conversation, event); // Automatically send a delivery // avoid sending delivered to our own events if (this.conversation.me.id !== textEvent.from) { textEvent.delivered(); } return textEvent; } } exports.default = ConversationEventHandler; module.exports = ConversationEventHandler; × Search results Close "},"pages_conversations_page.js.html":{"id":"pages_conversations_page.js.html","title":"Source: pages/conversations_page.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: pages/conversations_page.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * * Copyright (c) Nexmo Inc. */ const page_1 = __importDefault(require(\"./page\")); /** * A Conversations Page * * @class ConversationsPage * @param {Map} items map of conversations fetched in the paginated query * @extends Page */ class ConversationsPage extends page_1.default { constructor(params) { super(params); this.items = new Map(); // Iterate and create the conversations if not existent params.items.forEach((c) =&gt; { const conversation = this.application.updateOrCreateConversation(c); this.items.set(conversation.id, conversation); }); } /** * Fetch the previous page if exists * @returns {Promise&lt;Page&gt;} */ getPrev() { if (!this.hasPrev()) return this._getError(); return this.application.getConversations(this._getConfig(this.cursor.prev)); } /** * Fetch the next page if exists * @returns {Promise&lt;Page&gt;} */ getNext() { if (!this.hasNext()) return this._getError(); return this.application.getConversations(this._getConfig(this.cursor.next)); } } exports.default = ConversationsPage; module.exports = ConversationsPage; × Search results Close "},"pages_page.js.html":{"id":"pages_page.js.html","title":"Source: pages/page.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: pages/page.js 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * * Copyright (c) Nexmo Inc. */ const nexmoClientError_1 = require(\"../nexmoClientError\"); /** Page Class for Paginated Results * * @class Page * @param {number} page_size the number of resources returned in a single request list * @param {string} order 'asc' or 'desc' ordering of resources (usually based on creation time) * @param {string} cursor cursor parameter to access the next or previous page of a data set * @param {Application} application - the parent Application * @param {string} [event_type] the type of event used to filter event requests * * @private */ class Page { constructor(params = {}) { this.page_size = params.page_size; this.order = params.order; this.cursor = params.cursor; this.application = params.application; if (params.event_type &amp;&amp; params.event_type.length &gt; 0) { this.event_type = params.event_type; } } /** * Check if previous page exists * @returns {Boolean} */ hasPrev() { return this.cursor.prev ? this.cursor.prev.length &gt; 0 : false; } /** * Check if next page exists * @returns {Boolean} */ hasNext() { return this.cursor.next ? this.cursor.next.length &gt; 0 : false; } /** * Create config params for paginationRequest * @param {string} cursor cursor parameter to access the next or previous page of a data set * @returns {Object} */ _getConfig(cursor) { const config = { page_size: this.page_size, order: this.order, cursor: cursor }; if (this.event_type) { config.event_type = this.event_type; } return config; } /** * Create a nexmoClientError when page does not exist */ _getError() { return Promise.reject(new nexmoClientError_1.NexmoApiError({ type: 'error:invalid-cursor', description: 'page does not exist' })); } } exports.default = Page; module.exports = Page; × Search results Close "},"pages_events_page.js.html":{"id":"pages_events_page.js.html","title":"Source: pages/events_page.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: pages/events_page.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * * Copyright (c) Nexmo Inc. */ const page_1 = __importDefault(require(\"./page\")); const nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\")); const text_event_1 = __importDefault(require(\"../events/text_event\")); const image_event_1 = __importDefault(require(\"../events/image_event\")); /** * A Events Page * * @class EventsPage * @param {Map} items map of events fetched in the paginated query * @extends Page */ class EventsPage extends page_1.default { constructor(params) { super(params); this.items = new Map(); this.conversation = params.conversation; // Iterate and create the event objects params.items.forEach((event) =&gt; { switch (event.type) { // NXMEvent types with corresponding classes case 'text': this.items.set(event.id, new text_event_1.default(this.conversation, event)); break; case 'image': this.items.set(event.id, new image_event_1.default(this.conversation, event)); break; default: this.items.set(event.id, new nxmEvent_1.default(this.conversation, event)); break; } }); // update the events Map on the conversation this.conversation.events = new Map([...this.conversation.events, ...this.items]); } /** * Fetch the previous page if exists * @returns {Promise&lt;Page&gt;} */ getPrev() { if (!this.hasPrev()) return this._getError(); return this.conversation.getEvents(this._getConfig(this.cursor.prev)); } /** * Fetch the next page if exists * @returns {Promise&lt;Page&gt;} */ getNext() { if (!this.hasNext()) return this._getError(); return this.conversation.getEvents(this._getConfig(this.cursor.next)); } } exports.default = EventsPage; module.exports = EventsPage; × Search results Close "},"events_image_event.js.html":{"id":"events_image_event.js.html","title":"Source: events/image_event.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: events/image_event.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * ImageEvent Object Model * * Copyright (c) Nexmo Inc. */ const getLogger = require('loglevel').getLogger; const networkRequest = require('./../utils').networkRequest; const nxmEvent_1 = __importDefault(require(\"./nxmEvent\")); /** * An image event * * @class ImageEvent * @extends NXMEvent */ class ImageEvent extends nxmEvent_1.default { constructor(conversation, params) { super(conversation, params); this.log = getLogger(this.constructor.name); this.type = 'image'; this.conversation = conversation; this.state = { seen_by: {}, delivered_to: {} }; if (params &amp;&amp; params.body &amp;&amp; params.body.timestamp) { this.timestamp = params.body.timestamp; } Object.assign(this, params); } /** * Set the message status to 'seen' */ seen() { return super.seen(); } /** * Set the message status to 'delivered' */ delivered() { return super.delivered(); } /** * Delete the image event, all 3 representations of it * passing only the one of the three URLs * @param {object} [imageRepresentations=this.body.representations] the ImageEvent.body for the image to delete * @returns {Promise} */ async del(imageRepresentations = this.body.representations) { await networkRequest({ type: 'DELETE', url: imageRepresentations.original.url, token: this.conversation.application.session.config.token }); return super.del(); } /** * Download an Image from Media service //3 representations * @param {string} [type=\"thumbnail\"] original, medium, thumbnail, * @param {string} [representations=this.body.representations] the ImageEvent.body for the image to download * @returns {string} the dataUrl \"data:image/jpeg;base64...\" * @example &lt;caption&gt;Downloading an image from the imageEvent&lt;/caption&gt; * imageEvent.fetchImage().then((imagedata) =&gt; { * var img = new Image(); * img.onload = () =&gt; {}; * img.src = imagedata; * * // to cancel the request: * // conversation.abortSendImage(imageRequest); * }); */ async fetchImage(type = 'thumbnail', imageRepresentations = this.body.representations) { try { const { response } = await networkRequest({ type: 'GET', url: imageRepresentations[type].url, responseType: 'arraybuffer', token: this.conversation.application.session.config.token }); const responseArray = new Uint8Array(response); // Convert the int array to a binary String // We have to use apply() as we are converting an *array* // and String.fromCharCode() takes one or more single values, not // an array. // support large image files (Chunking) let res = ''; const chunk = 8 * 1024; let i; for (i = 0; i &lt; responseArray.length / chunk; i++) { res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk, (i + 1) * chunk)); } res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk)); return 'data:image/jpeg;base64,' + btoa(res); } catch (error) { this.log.error(error); throw error; } } } exports.default = ImageEvent; module.exports = ImageEvent; × Search results Close "},"member.js.html":{"id":"member.js.html","title":"Source: member.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: member.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Member Object Model * * Copyright (c) Nexmo Inc. */ const WildEmitter = require('wildemitter'); const nexmoClientError_1 = require(\"./nexmoClientError\"); const nxmEvent_1 = __importDefault(require(\"./events/nxmEvent\")); const utils_1 = __importDefault(require(\"./utils\")); /** * An individual user (i.e. conversation member). * @class Member * @param {Conversation} conversation * @param {object} params */ class Member { constructor(conversation, params) { this.conversation = conversation; this.callStatus = null; this._normalise(params); WildEmitter.mixin(Member); } /** * Update object instance and align attribute names * * Handle params input to keep consistent the member object * @param {object} params member attributes * @private */ _normalise(params) { if (params) { this.user = this.user || {}; this.channel = params.channel || { type: 'app' }; let key; for (key in params) { switch (key) { case \"member_id\": this.id = params.member_id; break; case \"timestamp\": this.timestamp = params.timestamp; break; case \"state\": this.state = params.state; break; case \"from\": this.id = params.from; // special case for member events break; case \"user_id\": this.user.id = params.user_id; break; case \"name\": this.user.name = params.name; break; case \"user\": this.user = { name: params.user.name, id: params.user.user_id || params.user.id }; this.display_name = this.display_name || params.user.display_name; break; case \"invited_by\": this.invited_by = params.invited_by; break; case \"display_name\": this.display_name = this.display_name || params.display_name; break; case \"conversation\": break; default: if (!params.type) { this[key] = params[key]; } } } // join conversation returns our member with only id, // compare it for now and use the username we have in the application object if (this.conversation.application.me &amp;&amp; params.user_id === this.conversation.application.me.id) { this.user.name = this.conversation.application.me.name; } // make sure we don't keep a member.user_id, name in any flow delete this.user_id; delete this.name; delete this.user.user_id; } } /** * Play the given stream only to this member within the conversation * * @param {string} [params] * * @returns {Promise&lt;NXMEvent&gt;} * @private */ async playStream(params) { try { const response = await this.conversation.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/events`, data: { type: 'audio:play', to: this.id, body: params } }); return new nxmEvent_1.default(this.conversation, response); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Speak the given text only to this member within the conversation * * @param {string} [params] * * @returns {Promise&lt;NXMEvent&gt;} * @private */ async sayText(params) { try { const response = await this.conversation.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.id}/events`, data: { type: 'audio:say', cid: this.id, from: this.conversation.me.id, to: this.id, body: { text: params.text, voice_name: params.voice_name || 'Amy', level: params.level || 1, queue: params.queue || true, loop: params.loop || 1, ssml: params.ssml || false } } }); return new nxmEvent_1.default(this.conversation, response); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Kick this member from the conversation * * @param {object} [reason] the reason for kicking out a member * @param {string} [reason.reason_code] the code of the reason * @param {string} [reason.reason_text] the description of the reason * @returns {Promise} */ async kick(reason) { let path = `conversations/${this.conversation.id}/members/${this.id}`; if (reason) { let params = new URLSearchParams(); Object.keys(reason).forEach((key) =&gt; { params.append(key, reason[key]); }); path += `?${params.toString()}`; } try { return await this.conversation.application.session.sendNetworkRequest({ type: 'DELETE', path }); } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Mute a stream * * @param {boolean} [mute] true for mute, false for unmute * @param {number} [streamIndex] stream index of the stream * @example &lt;caption&gt;Mute audio stream&lt;/caption&gt; * media.mute(true) * * @returns {Promise} */ mute(mute, streamIndex = null) { return this.conversation.media.mute(mute, streamIndex); } /** * Earmuff this member * * @param {boolean} earmuff true or false * * @returns {Promise} * */ earmuff(earmuff) { return this.conversation.media.earmuff(earmuff); } /** * Handle member object events * * Handle events that are modifying this member instance * @param {NXMEvent} event invited, joined, left, media events * @private */ _handleEvent(event) { switch (event.type) { case 'member:invited': this._normalise(event.body); // take care of misaligned objects. this.state = 'INVITED'; this.timestamp.invited = event.body.timestamp.invited; if (!event.body.invited_by &amp;&amp; event.body.user.media &amp;&amp; event.body.user.media.audio_settings &amp;&amp; event.body.user.media.audio_settings.enabled) { this._setCallStatusAndEmit('started'); } break; case 'member:joined': this._normalise(event.body); // take care of misaligned objects. this.state = 'JOINED'; this.timestamp.joined = event.body.timestamp.joined; if (event.body.channel &amp;&amp; event.body.channel.knocking_id) { this._setCallStatusAndEmit('started'); } break; case 'member:left': this._normalise(event.body); // take care of misaligned objects. this.state = 'LEFT'; this.timestamp.left = event.body.timestamp.left; if (event.body.reason &amp;&amp; event.body.reason.text) { this._setCallStatusAndEmit(event.body.reason.text); } break; case 'member:media': this.media = event.body.media; break; case 'leg:status:update': this.channel.legs = utils_1.default.updateMemberLegs(this.channel.legs, event); this._setCallStatusAndEmit(event.body.status); break; case 'audio:ringing:start': if (!this.callStatus || this.callStatus === 'started') { this._setCallStatusAndEmit('ringing'); } break; default: break; } } /** * Set the member.callStatus and emit a member:call:status event * * @param {Member.callStatus} this.callStatus the call status to set * @private */ _setCallStatusAndEmit(callStatus) { if (this.callStatus !== String(callStatus)) { this.callStatus = callStatus; this.conversation.emit('member:call:status', this); } } } exports.default = Member; module.exports = Member; × Search results Close "},"nexmoClientError.js.html":{"id":"nexmoClientError.js.html","title":"Source: nexmoClientError.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: nexmoClientError.js 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Nexmo Client - API Error wrapper * * Copyright (c) Nexmo Inc. */ const NexmoClientErrorTypes = require('./nexmoClientErrorTypes'); function decorateError(instance, error) { if (error &amp;&amp; error.code) { error.type = error.code; delete error['code']; } Object.assign(instance, error); instance.message = 'type: ' + instance.type + ', description: ' + (instance.description ? instance.description : ''); instance.stack = new Error().stack; } /** * Error constructor of an NexmoClient-error * @param {string} errorInput String client error */ class NexmoClientError { constructor(errorInput) { const error = NexmoClientErrorTypes[errorInput]; // for other errors (libs/browser APIs) re-use the Client error // to forward it but don't throw it away if (error) { // if error type exists in our list keep consistency decorateError(this, error); } else { // if the structure is not as expected, f/w as much as we can get this.message = errorInput &amp;&amp; errorInput.message ? errorInput.message : errorInput; this.stack = errorInput &amp;&amp; errorInput.stack ? errorInput.stack : new Error().stack; } // make sure the error.name matches the class name this.name = \"NexmoClientError\"; if (typeof global.NXMbugsnagClient !== \"undefined\") { global.NXMbugsnagClient.notify(this, { severity: \"info\" }); } } } exports.NexmoClientError = NexmoClientError; /** * Error constructor of an API-error * @param {object} error API error, always containing {type: &lt;string&gt;} */ class NexmoApiError { constructor(error) { decorateError(this, error); // make sure the error.name matches the class name this.name = 'NexmoApiError'; if (typeof global.NXMbugsnagClient !== \"undefined\") { global.NXMbugsnagClient.notify(this, { severity: \"info\", metaData: { \"API trace\": error.__metadata, rid: error.rid } }); } } } exports.NexmoApiError = NexmoApiError; module.exports = { NexmoClientError: NexmoClientError, NexmoApiError: NexmoApiError }; × Search results Close "},"events_nxmEvent.js.html":{"id":"events_nxmEvent.js.html","title":"Source: events/nxmEvent.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: events/nxmEvent.js 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * NXMEvent Object Model * * Copyright (c) Nexmo Inc. */ const WildEmitter = require('wildemitter'); const nexmoClientError_1 = require(\"../nexmoClientError\"); /** * Conversation NXMEvent Object. * The super class that holds the base events that apply to * common event objects. * @class NXMEvent */ class NXMEvent { constructor(conversation, params) { this.conversation = conversation; if (params) { for (const key in params) { switch (key) { case 'type': if (params.type.startsWith('custom:')) { this.type = params.type.replace('custom:', ''); } else { this.type = params.type; } break; case 'cid': this.cid = params.cid; break; case 'from': this.from = params.from; break; case 'timestamp': this.timestamp = params.timestamp; break; case 'id': this.id = params.id; break; case 'state': this.state = params.state; break; case 'index': this.index = params.index; break; case 'streamIndex': this.streamIndex = params.streamIndex; break; case 'body': this.body = params.body; if (this.body.user &amp;&amp; this.body.user.user_id) { this.body.user.id = this.body.user.user_id; delete this.body.user.user_id; } if (this.body.digit) { this.digit = this.body.digit; delete this.body.digit; } if (this.body.digits) { this.digit = this.body.digits; delete this.body.digits; } break; } } } WildEmitter.mixin(NXMEvent); } /** * Delete the event * @param {number} [event_id=this.event_id] if the event id param is not present, \"this\" event will be default * @returns {Promise} * @private */ async del(event_id = this.id) { try { await this.conversation.application.session.sendNetworkRequest({ type: 'DELETE', path: `conversations/${this.conversation.id}/events/${event_id}?from=${this.conversation.me.id}`, version: 'beta2' }); return; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } /** * Mark as Delivered the event * @param {number} [event_id=this.event_id] if the event id is not provided, the this event will be used * @returns {Promise} * @private */ async delivered(event_id = this.id) { if (this.type !== 'text' &amp;&amp; this.type !== 'image') { this.type = 'event'; } if (this.conversation.me.id === this.from) { throw new nexmoClientError_1.NexmoClientError('error:delivered:own-message'); } else if (this.state &amp;&amp; this.state.delivered_to &amp;&amp; this.state.delivered_to[this.conversation.me.id]) { throw new nexmoClientError_1.NexmoClientError('error:already-delivered'); } else { try { await this.conversation.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.conversation.id}/events`, data: { type: `${this.type}:delivered`, from: this.conversation.me.id, body: { event_id } } }); return; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } } /** * Mark as Seen the event * @param {number} [event_id=this.event_id] if the event id is not provided, the this event will be used * @returns {Promise} * @private */ async seen(event_id = this.id) { if (this.type !== 'text' &amp;&amp; this.type !== 'image') { this.type = 'event'; } if (this.conversation.me.id === this.from) { throw new nexmoClientError_1.NexmoClientError('error:seen:own-message'); } else if (this.state &amp;&amp; this.state.seen_by &amp;&amp; this.state.seen_by[this.conversation.me.id]) { throw new nexmoClientError_1.NexmoClientError('error:already-seen'); } else { try { await this.conversation.application.session.sendNetworkRequest({ type: 'POST', path: `conversations/${this.conversation.id}/events`, data: { type: `${this.type}:seen`, from: this.conversation.me.id, body: { event_id } } }); return; } catch (error) { throw new nexmoClientError_1.NexmoApiError(error); } } } } exports.default = NXMEvent; module.exports = NXMEvent; × Search results Close "},"modules_rtc_helper.js.html":{"id":"modules_rtc_helper.js.html","title":"Source: modules/rtc_helper.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: modules/rtc_helper.js 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * * Copyright (c) Nexmo Inc. */ require('webrtc-adapter'); const getLogger = require('loglevel').getLogger; const browserDetect = require('detect-browser'); /** * RTC helper object for accessing webRTC API. * @class RtcHelper * @private */ class RtcHelper { constructor() { this.log = getLogger(this.constructor.name); } getUserAudio(audioConstraints = true) { let constraintsToUse = { video: false, audio: audioConstraints }; return navigator.mediaDevices.getUserMedia(constraintsToUse); } createRTCPeerConnection(config) { const pc = new RTCPeerConnection(config); // attaching the .trace to make easier the stats reporting implementation pc.trace = () =&gt; { return; }; return pc; } _playAudioStream(stream) { const audio = new Audio(); audio.srcObject = stream; audio.autoplay = true; return audio; } _getWindowLocationProtocol() { return window.location.protocol; } _getBrowserName() { return browserDetect.detect().name; } isNode() { return this._getBrowserName() === 'node'; } /** * Check if the keys in an object are found in another object */ checkValidKeys(object, defaultObject) { let valid = true; Object.keys(object).forEach((key) =&gt; { if (!defaultObject.hasOwnProperty(key)) { valid = false; } ; }); return valid; } ; } exports.default = RtcHelper; module.exports = RtcHelper; × Search results Close "},"modules_rtcstats_rtcstats.js.html":{"id":"modules_rtcstats_rtcstats.js.html","title":"Source: modules/rtcstats/rtcstats.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: modules/rtcstats/rtcstats.js 'use strict'; const rtcStatsReporter = require('./rtcstats-reporter'); /** * Collect WebRTC Report data * Removes credential information from the STUN.TURN server configuration. * performs Delta compression * * if isCallback is true the report includes a MOS score : trace('mos', mos, report); * * @param {object} trace the function will be attached to the RTCPeerConnection object and will be used as a callback * @param {boolean} isCallback this set to true the reports will be passed uncompressed to the trace function: trace('mos', mos, res); * @param {number} getStatsInterval * @property {number} mos_report the final mos report to be sent when the stream is closed * @property {number} _reportsCount the number of reports taken for mos average * @property {number} _mosSum the summary of mos scores * @private */ class RTCStats { constructor(trace, isCallback, getStatsInterval, prefixesToWrap) { this.mos_report = { min: 5, max: 0 }; this._reportsCount = 0; this._mosSum = 0; let self = this; if (isCallback) { let OrigPeerConnection = window['RTCPeerConnection']; let peerconnection = function (config) { let pc = new OrigPeerConnection(config); if (!self.stats_interval) { self.stats_interval = window.setInterval(() =&gt; { if (pc.signalingState === 'closed') { window.clearInterval(self.stats_interval); let mos_report = self.getMOSReport(); trace('mos_report', mos_report.last, null, mos_report); return; } pc.getStats(null).then((res) =&gt; { let mos = self.getMos(res); trace('mos', mos, res); }); }, getStatsInterval); } return pc; }; window['RTCPeerConnection'] = peerconnection; window['RTCPeerConnection'].prototype = OrigPeerConnection.prototype; } else { rtcStatsReporter(trace, isCallback, getStatsInterval, prefixesToWrap); } } disable() { if (!this.stats_interval) { throw new Error('rtc stats not enabled'); } else { window.clearInterval(this.stats_interval); delete this.stats_interval; } } getMos(report) { let jitter_time = 0; let recv_pkts = 0; let lost_pkts = 0; let average = 100.0; let packet_loss = 0.0; let effective_latency; let r_value; let mos = 0; for (let now of report.values()) { if (now.type === 'inbound-rtp') { jitter_time = now.jitter; lost_pkts = now.packetsLost; recv_pkts = now.packetsReceived; } } if (recv_pkts + lost_pkts &gt; 0) { packet_loss = 100.0 * (lost_pkts / (recv_pkts + lost_pkts)); } effective_latency = (average + jitter_time * 2 + 10); if (effective_latency &lt; 160) { r_value = 93.2 - (effective_latency / 40); } else { r_value = 93.2 - (effective_latency - 120) / 10; } r_value = r_value - (packet_loss * 2.5); if (r_value &lt; 1) { r_value = 1; } mos = 1 + (0.035) * r_value + (0.000007) * r_value * (r_value - 60) * (100 - r_value); this.updateMOSReport(mos); return RTCStats.normaliseFloat(mos); } /** * Update the mos_report object * @param {number} mos the MOS score * @returns {object} the report object */ updateMOSReport(mos) { this._reportsCount++; this._mosSum += mos; this.mos_report.last = mos; this.mos_report.min = (mos &lt; this.mos_report.min) ? mos : this.mos_report.min; this.mos_report.max = (mos &gt; this.mos_report.max) ? mos : this.mos_report.max; this.mos_report.average = this._mosSum / this._reportsCount; return this.mos_report; } /** * Update the MOS report object * mos_report.min - the minimum MOS value during the stream * mos_report.max - the maximum MOS value during the stream * mos_report.last - the last MOS value during the stream * mos_report.average - the average MOS value during the stream * @returns {Object} mos_report - a report for the MOS values * */ getMOSReport() { this.mos_report.min = RTCStats.normaliseFloat(this.mos_report.min); this.mos_report.max = RTCStats.normaliseFloat(this.mos_report.max); this.mos_report.last = RTCStats.normaliseFloat(this.mos_report.last); this.mos_report.average = RTCStats.normaliseFloat(this.mos_report.average); return this.mos_report; } static normaliseFloat(value) { return parseFloat(value).toFixed(6); } } module.exports = RTCStats; × Search results Close "},"events_text_event.js.html":{"id":"events_text_event.js.html","title":"Source: events/text_event.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: events/text_event.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Text NXMEvent Object Model * * Copyright (c) Nexmo Inc. */ const nxmEvent_1 = __importDefault(require(\"./nxmEvent\")); /** * A text event * * @class TextEvent * @extends NXMEvent */ class TextEvent extends nxmEvent_1.default { constructor(conversation, params) { super(conversation, params); this.type = 'text'; this.conversation = conversation; this.state = { seen_by: {}, delivered_to: {} }; if (params &amp;&amp; params.body &amp;&amp; params.body.timestamp) { this.timestamp = params.body.timestamp; } Object.assign(this, params); } /** * Set the message status to 'seen' * @returns {Promise} */ seen() { return super.seen(); } /** * Set the message status to 'delivered'. * handled by the SDK * @returns {Promise} */ delivered() { return super.delivered(); } /** * Delete the event * @returns {Promise} */ del() { return super.del(); } } exports.default = TextEvent; module.exports = TextEvent; × Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Source: utils.js 'use strict'; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); /* * Nexmo Client SDK * Utility functions * * Copyright (c) Nexmo Inc. */ const uuid_1 = __importDefault(require(\"uuid\")); /** * Utilities class for the SDK. * * @class Utils * @private */ class Utils { /** * Get the Member from the username of a conversation * * @param {string} username the username of the member to get * @param {Conversation} conversation the Conversation to search in * @returns {Member} the requested Member * @static */ static getMemberFromNameOrNull(conversation, username) { if (!conversation || !username) return null; for (let member of conversation.members.values()) { if (member.user.name === username) { return member; } } return null; } /** * Get the Member's number or uri from the event's channel field * * @param {object} channel the event's channel field * @returns {string} the requested Member number or uri * @static */ static getMemberNumberFromEventOrNull(channel) { const from = channel &amp;&amp; channel.from; if (from &amp;&amp; (from.number || from.uri)) { return from.number || from.uri; } return null; } /** * Perform a network request to the given url * * @param {object} reqObject the object that has all the information for the request * @param {string} url the request url * @param {string} type=GET|POST|PUT|DELETE the types of the network request * @param {object} [data] the data that are going to be sent * @param {string} [responseType] the response type of the request * @param {string} token the jwt token for the network request * @returns {Promise&lt;XMLHttpRequest&gt;} the XMLHttpRequest * @static */ static networkRequest(reqObject) { return new Promise((resolve, reject) =&gt; { if (!reqObject.token) { // eslint-disable-next-line prefer-promise-reject-errors reject({ response: { type: 'error:user:token', description: 'network error on request. Please re-login' } }); } const xhr = new XMLHttpRequest(); let data; xhr.open(reqObject.type, reqObject.url, true); xhr.setRequestHeader('Authorization', 'Bearer ' + reqObject.token); if (reqObject &amp;&amp; reqObject.url.includes('image')) { xhr.responseType = ''; data = reqObject.data; xhr.onloadstart = () =&gt; { resolve(xhr); }; } else { xhr.responseType = reqObject.responseType || 'json'; data = JSON.stringify(reqObject.data) || null; xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8'); } xhr.onload = () =&gt; { if (xhr.status === 200 || xhr.status === 204) { resolve(xhr); } else { reject(xhr); } }; xhr.onerror = (error) =&gt; { reject(error); }; xhr.send(data); }); } /** * Perform a GET network request for fetching paginated conversations and events * * @param {string} url the request url * @param {object} [params] network request params * @param {string} [params.cursor] cursor parameter to access the next or previous page of a data set * @param {number} [params.page_size] the number of resources returned in a single request list * @param {string} [params.order] 'asc' or 'desc' ordering of resources (usually based on creation time) * @param {string} [params.event_type] the type of event used to filter event requests ('member:joined', 'audio:dtmf', etc) * @param {string} token the jwt token for the network request * * @returns {Promise&lt;XMLHttpRequest.response&gt;} the XMLHttpRequest * @static * @example &lt;caption&gt;Sending a nexmo GET request&lt;/caption&gt; * paginationRequest(url, params).then((response) =&gt; { * response.items: {}, * response.cursor: { * prev: '', * next: '', * self: '' * }, * response.page_size: 10, * response.order: 'asc', * }); */ static async paginationRequest(url, params, token) { try { const xhr = await Utils.networkRequest({ type: 'GET', url: Utils.addUrlSearchParams(url, params), token }); const { page_size, _embedded, _links } = xhr.response; const resource = url.split('/').pop().trim(); const response = { items: _embedded.data[resource], cursor: { prev: _links.prev ? new URLSearchParams(_links.prev.href).get('cursor') : '', next: _links.next ? new URLSearchParams(_links.next.href).get('cursor') : '', self: _links.self ? new URLSearchParams(_links.self.href).get('cursor') : '' }, page_size: page_size, order: params.order || 'asc', event_type: params.event_type || null }; return response; } catch ({ response }) { const parsed_error = response ? response : { type: 'error:network:get-request', description: 'network error on nexmo get request' }; if (parsed_error.validation) { parsed_error.description = parsed_error.validation[Object.keys(parsed_error.validation)[0]]; } throw parsed_error; } } /** * Update the Search Params of a url * @returns {string} the appended url * @static */ static addUrlSearchParams(url, params = {}) { let appended_url = new URL(url); Object.keys(params).forEach((key) =&gt; { if (params[key] &amp;&amp; !(typeof params[key] === 'string' &amp;&amp; params[key].length &lt; 1) &amp;&amp; params[key] !== null) { appended_url.searchParams.set(key, params[key]); } }); return appended_url.href; } /** * Deep merges two objects * @returns {Object} the new merged object * @static */ static deepMergeObj(obj1, obj2) { const mergedObj = JSON.parse(JSON.stringify(obj1)); // Merge the object into the new mergedObject for (let prop in obj2) { // If the property is an object then merge properties if (Object.prototype.toString.call(obj2[prop]) === '[object Object]') { mergedObj[prop] = Utils.deepMergeObj(mergedObj[prop], obj2[prop]); } else { mergedObj[prop] = obj2[prop]; } } return mergedObj; } /** * Inject a script into the document * * @param {string} s script being executed * @param {requestCallback} c the callback fired after script executed * @static */ static injectScript(u, c) { if (typeof document !== 'undefined') { let h = document.getElementsByTagName('head')[0]; let s = document.createElement('script'); s.async = true; s.src = u; s.onload = s.onreadystatechange = () =&gt; { if (!s.readyState || /loaded|complete/.test(s.readyState)) { s.onload = s.onreadystatechange = null; s = null; if (c) { c(); } } }; h.insertBefore(s, h.firstChild); } } static allocateUUID() { return uuid_1.default.v4(); } /** * Validate dtmf digit * @static */ static validateDTMF(digit) { return typeof digit === 'string' ? /^[\\da-dA-D#*pP]{1,45}$$/.test(digit) : false; } /** * Get the nexmo bugsnag api key * @private */ static _getBugsnagKey() { return '76498fc1ca8d9b0a173a44e2b873d7ed'; } /** * Update the member legs array with the new one received in the event * * @param {Array} legs the member legs array * @param {NXMEvent} event the member event holding the new legs array * @static */ static updateMemberLegs(legs, event) { if (legs) { // find the leg in the legs array if exists const leg = legs.find((leg) =&gt; leg.leg_id === event.body.leg_id); if (!leg) { legs.push({ leg_id: event.body.leg_id, status: event.body.status }); } else if (leg.status !== event.body.status) { // if the status of the leg is different from the event status // update the leg object with the new leg status let index = legs.indexOf(leg); legs.fill(leg.status = event.body.status, index, index++); } } else { legs = [{ leg_id: event.body.leg_id, status: event.body.status }]; } return legs; } } exports.default = Utils; module.exports = Utils; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Classes Classes Application Conversation ConversationsPage EventsPage ImageEvent Media Member NexmoApiError NexmoClient NexmoClientError NXMCall NXMEvent TextEvent Events call:status:changed NXMCall listening for nxmCall status changed events. Properties: Name Type Description nxmCall NXMCall the actual event Source: modules/nxmCall.js, line 46 Example listen for nxmCall status events application.on(\"call:status:changed\",(nxmCall) =&gt; { console.log(\"call: \" + nxmCall.status); }); NXM-errors Application listening for joins. Properties: Name Type Description error NexmoClientError Source: modules/errors_emitter.js, line 19 Examples listen for errors application.on('*', 'NXM-errors', (error) =&gt; { console.log('Error thrown with type ' + error.type); }); Update the token on expired-token error application.on('system:error:expired-token', 'NXM-errors', (error) =&gt; { console.log('token expired'); application.updateToken(&lt;token&gt;); }); member:call Application listening for calls. Properties: Name Type Description member Member the member that initiated the nxmCall nxmCall NXMCall resolves the nxmCall object Source: modules/nxmCall.js, line 33 Example listen for calls in Application level application.on(\"member:call\", (member, nxmCall) =&gt; { console.log(\"NXMCall \", nxmCall); }); member:invited Application listening for invites. Properties: Name Type Description member Member The invited member event NXMEvent The invitation event Source: application.js, line 86 Example listen for your invites application.on(\"member:invited\",(member, event) =&gt; { console.log(\"Invited to the conversation: \" + event.conversation.display_name || event.conversation.name); // identify the sender. console.log(\"Invited by: \" + member.invited_by); //accept an invitation. application.conversations.get(event.conversation.id).join(); //decline the invitation. application.conversations.get(event.conversation.id).leave(); member:joined Application listening for joins. Properties: Name Type Description member Member the member that joined the conversation event NXMEvent the join event Source: application.js, line 104 Example listen join events in Application level application.on(\"member:joined\",(member, event) =&gt; { console.log(\"JOINED\", \"Joined conversation: \" + event.conversation.display_name || event.conversation.name); }); rtcstats:report Application listening for RTC stats. Properties: Name Type Description MOS number the calculated MOS score report Object the stats report from WebRTC | when the call has ended this is null, see the mos_report for final MOS summary Conversation Conversation the conversation the report belongs to mos_report Object a report for the MOS values Properties Name Type Description min string the minimum MOS value during the stream max string the maximum MOS value during the stream last string the last MOS value during the stream average string the average MOS value during the stream Source: modules/media.js, line 86 Example listening for quality mos score application.on(\"rtcstats:report\",(mos, report, conversation, mos_report) =&gt; { console.log(\"call quality (MOS)\", mos); if (mos_report) { console.log('mos_report', mos_report); } }); sync:progress Application listening sync status. Properties: Name Type Description status.sync_progress number Percentage of fetched conversations Source: application.js, line 363 Example listening for changes in the synchronisation progress application.on(\"sync:progress\",(status) =&gt; { console.log(data.sync_progress); }); audio:mute:off Conversation listening for mute off events A member has unmuted their audio Properties: Name Type Description member Member the member object linked to this event event NXMEvent information about the mute event Source: sdk.js, line 495 audio:mute:on Conversation listening for mute on events A member has muted their audio Properties: Name Type Description member Member the member object linked to this event event NXMEvent information about the mute event Source: sdk.js, line 486 event:delete Conversation listening for deleted events. Properties: Name Type Description member Member the member who deleted an event event NXMEvent deleted event: event.id Source: sdk.js, line 345 Example get details about the deleted event conversation.on(\"event:delete\", (member, event) =&gt; { console.log(event.id); console.log(event.body.timestamp.deleted); }); image Conversation listening for image events. Properties: Name Type Description sender Member The sender of the image image ImageEvent The image message received Source: sdk.js, line 328 Example listen for image events conversation.on(\"image\", (sender, image) =&gt; { console.log(sender,image); // Identify your own imageEvent. if (image.from !== conversation.me.id) // Identify if the event corresponds to the currently open conversation. if (image.cid === conversation.id) }); text Conversation listening for text events. Properties: Name Type Description sender Member The sender of the text text TextEvent The text message received Source: sdk.js, line 312 Example listen for text events conversation.on(\"text\",(sender, message) =&gt; { console.log(sender,message); // Identify your own message. if (message.from !== conversation.me.id) // Identify if the event corresponds to the currently open conversation. if (message.cid === conversation.id) }); image:seen Conversation listening for members' seen images. Properties: Name Type Description member Member the member that saw the image image ImageEvent the image that was seen Source: sdk.js, line 451 Example listen for seen image events conversation.on(\"image:seen\", (data, image) =&gt; { console.log(image); // Check if the event belongs to this conversation if (image.cid === conversation.id) // Get the list of members that have seen this event for (let member_id in image.state.seen_by) { if (conversation.me.id !== member_id) { console.log(conversation.members.get(member_id).name); } } }); member:call:status Conversation listening for members callStatus changes. Properties: Name Type Description member Member the member that has left Source: sdk.js, line 383 Example get the callStatus of the member that changed call status conversation.on(\"member:call:status\", (member) =&gt; { console.log(member.callStatus); }); member:invited Conversation listening for members being invited. Properties: Name Type Description member Member the member that is invited event NXMEvent data regarding the receiver of the invitation Source: sdk.js, line 371 Example get the name of the invited member conversation.on(\"member:invited\", (member, event) =&gt; { console.log(member.user.name + \" invited to the conversation\"); }); member:joined Conversation listening for new members. Properties: Name Type Description member Member the member that joined event NXMEvent the join event Source: sdk.js, line 358 Example get the name of the new member conversation.on(\"member:joined\", (member, event) =&gt; { console.log(event.id) console.log(member.user.name+ \" joined the conversation\"); }); member:left Conversation listening for members leaving (kicked or left). Properties: Name Type Description member Member the member that has left event NXMEvent data regarding the receiver of the invitation Source: sdk.js, line 394 Example get the username of the member that left conversation.on(\"member:left\", (member , event) =&gt; { console.log(member.user.name + \" left\"); console.log(event.body.reason); }); member:media Conversation listening for members media changes (audio,text) Change in media presence state. They are in the conversation with text or audio. Properties: Name Type Description member Member the member object linked to this event event NXMEvent information about media presence state Properties Name Type Description body.audio boolean is audio enabled Source: sdk.js, line 470 Example get every member's media change events conversation.on(\"member:media\", (from, event) =&gt; { console.log(from.media.audio_settings.enabled); //true console.log(event.body.media); //{\"audio_settings\": {\"enabled\": true, \"muted\": false, \"earmuffed\": false}} }); text:seen Conversation listening for members' seen texts. Properties: Name Type Description member Member the member that saw the text text TextEvent the text that was seen Source: sdk.js, line 431 Example listen for seen text events conversation.on(\"text:seen\", (data, text) =&gt; { console.log(text); // Check if the event belongs to this conversation if (text.cid === conversation.id) // Get the list of members that have seen this event for (let member_id in text.state.seen_by) { if (conversation.me.id !== member_id) { console.log(conversation.members.get(member_id).name); } } }); text:typing:off Conversation listening for members stopped typing. Properties: Name Type Description member Member the member that stopped typing event NXMEvent the stop typing event Source: sdk.js, line 419 Example get the username of the member that stopped typing conversation.on(\"text:typing:off\", (data) =&gt; { console.log(data.name + \" stopped typing...\"); }); text:typing:on Conversation listening for members typing. Properties: Name Type Description member Member the member that started typing event NXMEvent the start typing event Source: sdk.js, line 407 Example get the username of the member that is typing conversation.on(\"text:typing:on\", (data) =&gt; { console.log(data.name + \" is typing...\"); }); media:stream:on Member listening for audio stream on. Properties: Name Type Argument Description payload.streamIndex number the index number of this stream payload.rtc_id number &lt;optional&gt; the rtc_id / leg_id payload.remote_member_id string &lt;optional&gt; the id of the Member the stream belongs to payload.name string &lt;optional&gt; the stream's display name payload.stream MediaStream the stream that is activated payload.audio_mute boolean &lt;optional&gt; if the audio is muted Source: modules/media.js, line 19 connecting Connecting event. Source: sdk.js, line 203 Example Listen to websocket connecting event rtc.on(\"connecting\", () =&gt; { console.log(\"connecting\"); }); disconnect Disconnect event. Source: sdk.js, line 216 Example Listen to websocket disconnect event rtc.on(\"disconnect\", () =&gt; { console.log(\"disconnect\"); }); error Error event. Source: sdk.js, line 255 Example Listen to websocket error event rtc.on(\"error\", (error) =&gt; { console.log(\"error\", error); }); ready Ready event. Source: sdk.js, line 188 Example Listen to websocket ready event rtc.on(\"ready\", () =&gt; { console.log(\"connection ready\"); }); reconnect Reconnect event. Source: sdk.js, line 229 Example Listen to websocket reconnect event rtc.on(\"reconnect\", (retry_number) =&gt; { console.log(\"reconnect\", retry_number); }); reconnecting Reconnecting event. Source: sdk.js, line 242 Example Listen to websocket reconnecting event rtc.on(\"reconnecting\", (retry_number): void =&gt; { console.log(\"reconnecting\", retry_number); }); × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Nexmo Client SDK for JavaScript The Client SDK is intended to provide a ready solution for developers who want to integrate chat, voice and video into their apps. Installation NPM A dependency manager for Node packages. You can install the Client SDK with the following command: npm install nexmo-client SDK Setup Include the nexmoClient.js script in your web page &lt;script src=\"node_modules/nexmo-client/dist/nexmoClient.js\"&gt;&lt;/script&gt; Or the minified version &lt;script src=\"node_modules/nexmo-client/dist/nexmoClient.min.js\"&gt;&lt;/script&gt; Testing We use third party tools for testing the framework: Karma: Karma is our test runner Mocha: Mocha is a feature-rich JavaScript test framework running on Node.js and in the browser, making asynchronous testing simple and fun. Chai: Chai is a BDD / TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework. Code style &amp; Conventions https://github.com/google/eslint-config-google License Copyright (c) 2019 Nexmo, Inc. All rights reserved. Licensed only under the Nexmo Client SDK License Agreement (the \"License\") located at LICENCE. By downloading or otherwise using our software or services, you acknowledge that you have read, understand and agree to be bound by the Nexmo Client SDK License Agreement and Privacy Policy. You may not use, exercise any rights with respect to or exploit this SDK, or any modifications or derivative works thereof, except in accordance with the License. × Search results Close "},"Application.html":{"id":"Application.html","title":"Class: Application","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: Application Application new Application(SDK, params) Core application class for the SDK. Application is the parent object holding the list of conversations, the session object. Provides methods to create conversations and retrieve a list of the user's conversations, while it holds the listeners for user's invitations Parameters: Name Type Description SDK NexmoClient session Object params object Source: application.js, line 27 Fires: Application#member:invited Application#member:joined Application#event:NXM-errors Example Accessing the list of conversations rtc.login(token).then((application) =&gt; { console.log(application.conversations); console.log(application.me.name, application.me.id); }); Methods &lt;async&gt; callServer(user [, type]) Creates a call to phone a number. The call object is created under application.calls when the call has started. listen for it with application.on(\"call:status:changed\") You don't need to start the stream, the SDK will play the audio for you Parameters: Name Type Argument Default Description user string the phone number or the username you want to call type string &lt;optional&gt; \"phone\" the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\") Source: application.js, line 229 Returns: Type Promise.&lt;NXMCall&gt; Example Create a call to a phone application.on(\"call:status:changed\", (nxmCall) =&gt; { if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) { console.log('the call has started'); } }); application.callServer(phone_number).then(() =&gt; { console.log('Calling phone ' + phone_number); }); &lt;async&gt; getConversation(id) Query the service to see if this conversation exists with the logged in user as a member and retrieve the data object Result added (or updated) in this.conversations Parameters: Name Type Description id string the id of the conversation to fetch Source: application.js, line 308 Returns: the requested conversation Type Promise.&lt;Conversation&gt; &lt;async&gt; getConversations(params) Query the service to obtain a complete list of conversations of which the logged-in user is a member with a state of JOINED or INVITED. Parameters: Name Type Description params object configure defaults for paginated conversations query Properties Name Type Argument Description order string 'asc' or 'desc' ordering of resources based on creation time page_size number the number of resources returned in a single request list cursor string &lt;optional&gt; string to access the starting point of a dataset Source: application.js, line 348 Returns: Populate Application.conversations. Type Promise.&lt;Page.&lt;Map.&lt;Conversation&gt;&gt;&gt; Example Get Conversations application.getConversations({ page_size: 20 ).then((conversations_page) =&gt; { conversations_page.items.forEach(conversation =&gt; { render(conversation) }) }); &lt;async&gt; getUser( [id]) Get Details of a user Parameters: Name Type Argument Description id string &lt;optional&gt; the id of the user to fetch, if skipped, it returns your own user details Source: application.js, line 410 Returns: Type Promise.&lt;User&gt; &lt;async&gt; inAppCall(usernames) Creates a call to specified user/s. Parameters: Name Type Description usernames Array.&lt;string&gt; the user names for those we want to call Source: application.js, line 193 Returns: a NXMCall object with all the call properties Type Promise.&lt;NXMCall&gt; &lt;async&gt; newConversation( [params]) Query the service to create a new conversation The conversation name must be unique per application. Parameters: Name Type Argument Description params object &lt;optional&gt; leave empty to get a GUID as name Properties Name Type Description name string the name of the conversation. A UID will be assigned if this is skipped display_name string the display_name of the conversation. Source: application.js, line 259 Returns: the created Conversation Type Promise.&lt;Conversation&gt; Example Create a conversation and join application.newConversation().then((conversation) =&gt; { //join the created conversation conversation.join().then((member) =&gt; { //Get the user's member belonging in this conversation. //You can also access it via conversation.me console.log(\"Joined as \" + member.user.name); }).catch((error) =&gt; { console.log(error); }); newConversationAndJoin( [params]) Query the service to create a new conversation and join it The conversation name must be unique per application. Parameters: Name Type Argument Description params object &lt;optional&gt; leave empty to get a GUID as name Properties Name Type Description name string the name of the conversation. A UID will be assigned if this is skipped display_name string the display_name of the conversation. Source: application.js, line 293 Returns: the created Conversation Type Promise.&lt;Conversation&gt; Example Create a conversation and join application.newConversationAndJoin().then((conversation) =&gt; { //join the created conversation conversation.join().then((member) =&gt; { //Get the user's member belonging in this conversation. //You can also access it via conversation.me console.log(\"Joined as \" + member.user.name); }).catch((error) =&gt; { console.log(error); }); syncConversations() Fetching all the conversations and sync progress events Source: application.js, line 377 updateToken(token) update user's token Parameters: Name Type Description token string the new token Source: application.js, line 157 Returns: Type Promise Events call:status:changed NXMCall listening for nxmCall status changed events. Properties: Name Type Description nxmCall NXMCall the actual event Source: modules/nxmCall.js, line 46 Example listen for nxmCall status events application.on(\"call:status:changed\",(nxmCall) =&gt; { console.log(\"call: \" + nxmCall.status); }); NXM-errors Application listening for joins. Properties: Name Type Description error NexmoClientError Source: modules/errors_emitter.js, line 19 Examples listen for errors application.on('*', 'NXM-errors', (error) =&gt; { console.log('Error thrown with type ' + error.type); }); Update the token on expired-token error application.on('system:error:expired-token', 'NXM-errors', (error) =&gt; { console.log('token expired'); application.updateToken(&lt;token&gt;); }); member:call Application listening for calls. Properties: Name Type Description member Member the member that initiated the nxmCall nxmCall NXMCall resolves the nxmCall object Source: modules/nxmCall.js, line 33 Example listen for calls in Application level application.on(\"member:call\", (member, nxmCall) =&gt; { console.log(\"NXMCall \", nxmCall); }); member:invited Application listening for invites. Properties: Name Type Description member Member The invited member event NXMEvent The invitation event Source: application.js, line 86 Example listen for your invites application.on(\"member:invited\",(member, event) =&gt; { console.log(\"Invited to the conversation: \" + event.conversation.display_name || event.conversation.name); // identify the sender. console.log(\"Invited by: \" + member.invited_by); //accept an invitation. application.conversations.get(event.conversation.id).join(); //decline the invitation. application.conversations.get(event.conversation.id).leave(); member:joined Application listening for joins. Properties: Name Type Description member Member the member that joined the conversation event NXMEvent the join event Source: application.js, line 104 Example listen join events in Application level application.on(\"member:joined\",(member, event) =&gt; { console.log(\"JOINED\", \"Joined conversation: \" + event.conversation.display_name || event.conversation.name); }); rtcstats:report Application listening for RTC stats. Properties: Name Type Description MOS number the calculated MOS score report Object the stats report from WebRTC | when the call has ended this is null, see the mos_report for final MOS summary Conversation Conversation the conversation the report belongs to mos_report Object a report for the MOS values Properties Name Type Description min string the minimum MOS value during the stream max string the maximum MOS value during the stream last string the last MOS value during the stream average string the average MOS value during the stream Source: modules/media.js, line 86 Example listening for quality mos score application.on(\"rtcstats:report\",(mos, report, conversation, mos_report) =&gt; { console.log(\"call quality (MOS)\", mos); if (mos_report) { console.log('mos_report', mos_report); } }); sync:progress Application listening sync status. Properties: Name Type Description status.sync_progress number Percentage of fetched conversations Source: application.js, line 363 Example listening for changes in the synchronisation progress application.on(\"sync:progress\",(status) =&gt; { console.log(data.sync_progress); }); × Search results Close "},"Conversation.html":{"id":"Conversation.html","title":"Class: Conversation","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: Conversation Conversation new Conversation() A single conversation Object. Properties: Name Type Argument Description me Member my Member object that belongs to this conversation application Application the parent Application name string the name of the Conversation (unique) display_name string &lt;optional&gt; the display_name of the Conversation members Map.&lt;string, Member&gt; &lt;optional&gt; the members of the Conversation keyed by a member's id events Map.&lt;string, NXMEvent&gt; &lt;optional&gt; the events of the Conversation keyed by an event's id sequence_number number &lt;optional&gt; the last event id Source: conversation.js, line 23 Members me :Member A Member Object representing the current user. Only set if the user is or has been a member of the Conversation, otherwise the value will be null. Type: Member Source: conversation.js, line 55 Methods abortSendImage(imageRequest) Cancel sending an Image message to the conversation. Parameters: Name Type Description imageRequest XMLHttpRequest Source: conversation.js, line 483 Returns: void Example cancel sending an image conversation.sendImage(fileInput.files[0]).then((imageRequest) =&gt; { conversation.abortSendImage(imageRequest); }); &lt;async&gt; del() Delete a conversation Source: conversation.js, line 196 Returns: Type Promise Example delete the conversation conversation.del().then(() =&gt; { console.log(\"conversation deleted\"); }) deleteEvent(event) Delete an NXMEvent (e.g. Text) Parameters: Name Type Description event NXMEvent Source: conversation.js, line 215 Returns: Type Promise &lt;async&gt; getEvents(params) Query the service to get a list of events in this conversation. Parameters: Name Type Description params object configure defaults for paginated events query Properties Name Type Argument Description order string 'asc' or 'desc' ordering of resources based on creation time page_size number the number of resources returned in a single request list cursor string &lt;optional&gt; string to access the starting point of a dataset event_type string &lt;optional&gt; the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*' Source: conversation.js, line 546 Returns: Populate Conversations.events. Type Promise.&lt;EventsPage.&lt;Map.&lt;Events&gt;&gt;&gt; Example Get Events conversation.getEvents({ event_type: 'member:*' ).then((events_page) =&gt; { events_page.items.forEach(event =&gt; { render(event) }) }); &lt;async&gt; invite(params) Invite the given user (id or name) to this conversation Parameters: Name Type Description params Member Properties Name Type Argument Description id or username string &lt;optional&gt; the id or the username of the user to invite Source: conversation.js, line 239 Returns: Type Promise.&lt;Member&gt; Example invite a user to a conversation const user_id = 'user to invite'; const user_name = 'username to invite'; conversation.invite({ id: user_id, user_name: user_name }).then((member) =&gt; { displayMessage(member.state + \" user: \" + user_id + \" \" + user_name); }).catch((error) =&gt; { console.log(error); }); inviteWithAudio(params) Invite the given user (id or name) to this conversation with media audio Parameters: Name Type Description params Member Properties Name Type Argument Description id or username string &lt;optional&gt; the id or the username of the user to invite Source: conversation.js, line 296 Returns: Type Promise.&lt;Member&gt; Example invite a user to a conversation const user_id = 'user to invite'; const user_name = 'username to invite'; conversation.inviteWithAudio({ id: user_id, user_name: user_name }).then((member) =&gt; { displayMessage(member.state + \" user: \" + user_id + \" \" + user_name); }).catch((error) =&gt; { console.log(error); }); &lt;async&gt; join( [params]) Join the given user to this conversation, will typically use this to join ourselves to a conversation we create. Accept an invitation if our member has state INVITED and no user_id / user_name is given Parameters: Name Type Argument Default Description params object &lt;optional&gt; this.application.me.id The user to join (defaults to this) Properties Name Type Description user_name string the user_name of the user to join user_id string the user_id of the user to join Source: conversation.js, line 142 Returns: Type Promise.&lt;Member&gt; Example join a user to a conversation conversation.join().then((member) =&gt; { console.log(\"joined as member: \", member) }) leave( [reason]) Leave from the conversation Parameters: Name Type Argument Description reason object &lt;optional&gt; the reason for leaving the conversation Properties Name Type Argument Description reason_code string &lt;optional&gt; the code of the reason reason_text string &lt;optional&gt; the description of the reason Source: conversation.js, line 316 Returns: Type Promise &lt;async&gt; sendCustomEvent(params, type, body) Send a custom event to the conversation Parameters: Name Type Description params object params of the custom event type string the name of the custom event. Must not exceed 100 char length and contain only alpha numerics and '-' and '_' characters. body object customizable key value pairs Source: conversation.js, line 375 Returns: the custom event that was sent Type Promise.&lt;NXMEvent&gt; Example sending a custom event conversation.sendCustomEvent({ type: 'my-event', body: {}}).then(() =&gt; { console.log('custom event was sent'); }).catch((error)=&gt;{ console.log('error sending the custom event', error); }); &lt;async&gt; sendImage(file) Send an Image message to the conversation, which will be relayed to every other member of the conversation. implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest Parameters: Name Type Argument Default Description file File single input file (jpeg/jpg) params.quality_ratio string &lt;optional&gt; 100 a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image params.medium_size_ratio string &lt;optional&gt; 50 a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original params.thumbnail_size_ratio string &lt;optional&gt; 10 a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original Source: conversation.js, line 424 Returns: Type Promise.&lt;XMLHttpRequest&gt; Example sending an image conversation.sendImage(fileInput.files[0]).then((imageRequest) =&gt; { imageRequest.onabort = (e) =&gt; { console.log(e); console.log(\"Image:\" + e.type); }; imageRequest.onloadend = (e) =&gt; { console.log(\"Image:\" + e.type); }; }); &lt;async&gt; sendText(text) Send a text message to the conversation, which will be relayed to every other member of the conversation Parameters: Name Type Description text string the text message to be sent Source: conversation.js, line 333 Returns: the text message that was sent Type Promise.&lt;TextEvent&gt; Example sending a text conversation.sendText(\"Hi Nexmo\").then(() =&gt; { console.log('message was sent'); }).catch((error)=&gt;{ console.log('error sending the message', error); }); startTyping() Send start typing indication Source: conversation.js, line 518 Returns: resolves the promise on successful sent Type Promise stopTyping() Send stop typing indication Source: conversation.js, line 526 Returns: resolves the promise on successful sent Type Promise Events audio:mute:off Conversation listening for mute off events A member has unmuted their audio Properties: Name Type Description member Member the member object linked to this event event NXMEvent information about the mute event Source: sdk.js, line 495 audio:mute:on Conversation listening for mute on events A member has muted their audio Properties: Name Type Description member Member the member object linked to this event event NXMEvent information about the mute event Source: sdk.js, line 486 event:delete Conversation listening for deleted events. Properties: Name Type Description member Member the member who deleted an event event NXMEvent deleted event: event.id Source: sdk.js, line 345 Example get details about the deleted event conversation.on(\"event:delete\", (member, event) =&gt; { console.log(event.id); console.log(event.body.timestamp.deleted); }); image Conversation listening for image events. Properties: Name Type Description sender Member The sender of the image image ImageEvent The image message received Source: sdk.js, line 328 Example listen for image events conversation.on(\"image\", (sender, image) =&gt; { console.log(sender,image); // Identify your own imageEvent. if (image.from !== conversation.me.id) // Identify if the event corresponds to the currently open conversation. if (image.cid === conversation.id) }); text Conversation listening for text events. Properties: Name Type Description sender Member The sender of the text text TextEvent The text message received Source: sdk.js, line 312 Example listen for text events conversation.on(\"text\",(sender, message) =&gt; { console.log(sender,message); // Identify your own message. if (message.from !== conversation.me.id) // Identify if the event corresponds to the currently open conversation. if (message.cid === conversation.id) }); image:seen Conversation listening for members' seen images. Properties: Name Type Description member Member the member that saw the image image ImageEvent the image that was seen Source: sdk.js, line 451 Example listen for seen image events conversation.on(\"image:seen\", (data, image) =&gt; { console.log(image); // Check if the event belongs to this conversation if (image.cid === conversation.id) // Get the list of members that have seen this event for (let member_id in image.state.seen_by) { if (conversation.me.id !== member_id) { console.log(conversation.members.get(member_id).name); } } }); member:call:status Conversation listening for members callStatus changes. Properties: Name Type Description member Member the member that has left Source: sdk.js, line 383 Example get the callStatus of the member that changed call status conversation.on(\"member:call:status\", (member) =&gt; { console.log(member.callStatus); }); member:invited Conversation listening for members being invited. Properties: Name Type Description member Member the member that is invited event NXMEvent data regarding the receiver of the invitation Source: sdk.js, line 371 Example get the name of the invited member conversation.on(\"member:invited\", (member, event) =&gt; { console.log(member.user.name + \" invited to the conversation\"); }); member:joined Conversation listening for new members. Properties: Name Type Description member Member the member that joined event NXMEvent the join event Source: sdk.js, line 358 Example get the name of the new member conversation.on(\"member:joined\", (member, event) =&gt; { console.log(event.id) console.log(member.user.name+ \" joined the conversation\"); }); member:left Conversation listening for members leaving (kicked or left). Properties: Name Type Description member Member the member that has left event NXMEvent data regarding the receiver of the invitation Source: sdk.js, line 394 Example get the username of the member that left conversation.on(\"member:left\", (member , event) =&gt; { console.log(member.user.name + \" left\"); console.log(event.body.reason); }); member:media Conversation listening for members media changes (audio,text) Change in media presence state. They are in the conversation with text or audio. Properties: Name Type Description member Member the member object linked to this event event NXMEvent information about media presence state Properties Name Type Description body.audio boolean is audio enabled Source: sdk.js, line 470 Example get every member's media change events conversation.on(\"member:media\", (from, event) =&gt; { console.log(from.media.audio_settings.enabled); //true console.log(event.body.media); //{\"audio_settings\": {\"enabled\": true, \"muted\": false, \"earmuffed\": false}} }); text:seen Conversation listening for members' seen texts. Properties: Name Type Description member Member the member that saw the text text TextEvent the text that was seen Source: sdk.js, line 431 Example listen for seen text events conversation.on(\"text:seen\", (data, text) =&gt; { console.log(text); // Check if the event belongs to this conversation if (text.cid === conversation.id) // Get the list of members that have seen this event for (let member_id in text.state.seen_by) { if (conversation.me.id !== member_id) { console.log(conversation.members.get(member_id).name); } } }); text:typing:off Conversation listening for members stopped typing. Properties: Name Type Description member Member the member that stopped typing event NXMEvent the stop typing event Source: sdk.js, line 419 Example get the username of the member that stopped typing conversation.on(\"text:typing:off\", (data) =&gt; { console.log(data.name + \" stopped typing...\"); }); text:typing:on Conversation listening for members typing. Properties: Name Type Description member Member the member that started typing event NXMEvent the start typing event Source: sdk.js, line 407 Example get the username of the member that is typing conversation.on(\"text:typing:on\", (data) =&gt; { console.log(data.name + \" is typing...\"); }); × Search results Close "},"ConversationsPage.html":{"id":"ConversationsPage.html","title":"Class: ConversationsPage","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: ConversationsPage ConversationsPage new ConversationsPage(items) A Conversations Page Parameters: Name Type Description items Map map of conversations fetched in the paginated query Source: pages/conversations_page.js, line 12 Extends Page Methods _getConfig(cursor) Create config params for paginationRequest Parameters: Name Type Description cursor string cursor parameter to access the next or previous page of a data set Inherited From: Page#_getConfig Source: pages/page.js, line 49 Returns: Type Object _getError() Create a nexmoClientError when page does not exist Inherited From: Page#_getError Source: pages/page.js, line 63 getNext() Fetch the next page if exists Source: pages/conversations_page.js, line 42 Returns: Type Promise.&lt;Page&gt; getPrev() Fetch the previous page if exists Source: pages/conversations_page.js, line 33 Returns: Type Promise.&lt;Page&gt; hasNext() Check if next page exists Inherited From: Page#hasNext Source: pages/page.js, line 41 Returns: Type Boolean hasPrev() Check if previous page exists Inherited From: Page#hasPrev Source: pages/page.js, line 34 Returns: Type Boolean × Search results Close "},"EventsPage.html":{"id":"EventsPage.html","title":"Class: EventsPage","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: EventsPage EventsPage new EventsPage(items) A Events Page Parameters: Name Type Description items Map map of events fetched in the paginated query Source: pages/events_page.js, line 15 Extends Page Methods _getConfig(cursor) Create config params for paginationRequest Parameters: Name Type Description cursor string cursor parameter to access the next or previous page of a data set Inherited From: Page#_getConfig Source: pages/page.js, line 49 Returns: Type Object _getError() Create a nexmoClientError when page does not exist Inherited From: Page#_getError Source: pages/page.js, line 63 getNext() Fetch the next page if exists Source: pages/events_page.js, line 58 Returns: Type Promise.&lt;Page&gt; getPrev() Fetch the previous page if exists Source: pages/events_page.js, line 49 Returns: Type Promise.&lt;Page&gt; hasNext() Check if next page exists Inherited From: Page#hasNext Source: pages/page.js, line 41 Returns: Type Boolean hasPrev() Check if previous page exists Inherited From: Page#hasPrev Source: pages/page.js, line 34 Returns: Type Boolean × Search results Close "},"ImageEvent.html":{"id":"ImageEvent.html","title":"Class: ImageEvent","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: ImageEvent ImageEvent new ImageEvent() An image event Source: events/image_event.js, line 15 Extends NXMEvent Methods &lt;async&gt; del( [imageRepresentations]) Delete the image event, all 3 representations of it passing only the one of the three URLs Parameters: Name Type Argument Default Description imageRepresentations object &lt;optional&gt; this.body.representations the ImageEvent.body for the image to delete Overrides: NXMEvent#del Source: events/image_event.js, line 54 Returns: Type Promise delivered() Set the message status to 'delivered' Overrides: NXMEvent#delivered Source: events/image_event.js, line 45 &lt;async&gt; fetchImage( [type] [, representations]) Download an Image from Media service //3 representations Parameters: Name Type Argument Default Description type string &lt;optional&gt; \"thumbnail\" original, medium, thumbnail, representations string &lt;optional&gt; this.body.representations the ImageEvent.body for the image to download Source: events/image_event.js, line 77 Returns: the dataUrl \"data:image/jpeg;base64...\" Type string Example Downloading an image from the imageEvent imageEvent.fetchImage().then((imagedata) =&gt; { var img = new Image(); img.onload = () =&gt; {}; img.src = imagedata; // to cancel the request: // conversation.abortSendImage(imageRequest); }); seen() Set the message status to 'seen' Overrides: NXMEvent#seen Source: events/image_event.js, line 39 × Search results Close "},"Media.html":{"id":"Media.html","title":"Class: Media","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: Media Media new Media() WebRTC Media class Properties: Name Type Description application Application The parent application object parentConversation Conversation the conversation object this media instance belongs to Properties Name Type Description streamIndex number the latest index of the streams, updated in each new peer offer rtcObjects Array.&lt;object&gt; data related to the rtc connection Properties Name Type Argument Description rtc_id string the rtc_id pc PeerConnection the current PeerConnection object stream Stream the stream of the specific rtc_id type string &lt;optional&gt; audio the type of the stream streamIndex number the index number of the stream (e.g. use to mute) Source: modules/media.js, line 31 Fires: Application#rtcstats:report Member#media:stream:on Methods _cleanMediaProperties() Cleans up the user's media before leaving the conversation Source: modules/media.js, line 354 disable() Disable media participation in the conversation for this application if RtcStats MOS is enabled, a final report will be available in NexmoClient#rtcstats:report Source: modules/media.js, line 598 Returns: Type Promise Example function disable() { conversation.media.disable() .then((response) =&gt; { }).catch((error) =&gt; { console.log(error); }); } &lt;async&gt; enable(params) Enable media participation in the conversation for this application (requires WebRTC) Parameters: Name Type Description params object rtc params Properties Name Type Argument Default Description label string Label is an application defined tag, eg. ‘fullscreen’ audio object &lt;optional&gt; true audio enablement mode. possible values \"both\", \"send_only\", \"receive_only\", \"none\", true or false autoPlayAudio object &lt;optional&gt; false attach the audio stream automatically to start playing after enable media (default false) Source: modules/media.js, line 558 Returns: Type Promise.&lt;MediaStream&gt; Example Enable media in this conversation function enable() { conversation.media.enable() .then((stream) =&gt; { const media = document.createElement(\"audio\"); const source = document.createElement(\"source\"); const media_div = document.createElement(\"div\"); media.appendChild(source); media_div.appendChild(media); document.insertBefore(media_div); // Older browsers may not have srcObject if (\"srcObject\" in media) { media.srcObject = stream; } else { // Avoid using this in new browsers, as it is going away. media.src = window.URL.createObjectURL(stream); } media.onloadedmetadata = (e) =&gt; { media.play(); }; }).catch((error) =&gt; { console.log(error); }); } mute( [mute] [, streamIndex]) Mute our member Parameters: Name Type Argument Default Description mute boolean &lt;optional&gt; false true for mute, false for unmute streamIndex number &lt;optional&gt; null stream id to set - if it's not set all streams will be muted Source: modules/media.js, line 468 Example Mute audio stream in conversation media.mute(true) &lt;async&gt; playStream() Play an audio stream in a conversation Source: modules/media.js, line 691 Returns: Type Promise.&lt;NXMEvent&gt; &lt;async&gt; sayText(params) Play a voice text in a conversation Parameters: Name Type Description params object Properties Name Type Description text string the text to say in the conversation voice_name string level number [0] - queue boolean loop boolean Source: modules/media.js, line 619 Returns: Type Promise.&lt;NXMEvent&gt; Example conversation.media.sayText({text:'hi'}); &lt;async&gt; sendDTMF(digit) Send DTMF in a conversation Parameters: Name Type Description digit string the DTMF digit(s) to send Source: modules/media.js, line 652 Returns: Type Promise.&lt;NXMEvent&gt; Example conversation.media.sendDTMF('digit'); &lt;async&gt; startRinging() Send start ringing event Source: modules/media.js, line 724 Returns: Type Promise.&lt;NXMEvent&gt; Example Send ringing event function startRinging() { conversation.media.startRinging() .then((response) =&gt; { }).catch((error) =&gt; { console.log(error); }); } conversation.on('audio:ringing:start', (data) =&gt; { console.log(\"ringing\"); }); &lt;async&gt; stopRinging() Send stop ringing event Source: modules/media.js, line 758 Returns: Type Promise.&lt;NXMEvent&gt; Example Send ringing event function stopRinging() { conversation.media.stopRinging() .then((response) =&gt; { }).catch((error) =&gt; { console.log(error); }); } conversation.on('audio:ringing:stop', (data) =&gt; { console.log(\"ringing stopped\"); } updateAudioConstraints(constraints, type) Replaces the stream's audio tracks currently being used as the sender's sources with a new one Parameters: Name Type Argument Description constraints object audio constraints type string rtc object type constraints.audio object &lt;optional&gt; set audio constraints - { deviceId: { exact: microphoneId } } Source: modules/media.js, line 438 Returns: Returns the new stream. Type Promise.&lt;MediaStream&gt; Example &lt;caption&gt;Update the stream currently being used with a new one&lt;/caption&gt; × Search results Close "},"Member.html":{"id":"Member.html","title":"Class: Member","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: Member Member new Member(conversation, params) An individual user (i.e. conversation member). Parameters: Name Type Description conversation Conversation params object Source: member.js, line 16 Methods earmuff(earmuff) Earmuff this member Parameters: Name Type Description earmuff boolean true or false Source: member.js, line 202 Returns: Type Promise &lt;async&gt; kick( [reason]) Kick this member from the conversation Parameters: Name Type Argument Description reason object &lt;optional&gt; the reason for kicking out a member Properties Name Type Argument Description reason_code string &lt;optional&gt; the code of the reason reason_text string &lt;optional&gt; the description of the reason Source: member.js, line 162 Returns: Type Promise mute( [mute] [, streamIndex]) Mute a stream Parameters: Name Type Argument Default Description mute boolean &lt;optional&gt; true for mute, false for unmute streamIndex number &lt;optional&gt; null stream index of the stream Source: member.js, line 191 Returns: Type Promise Example Mute audio stream media.mute(true) Events media:stream:on Member listening for audio stream on. Properties: Name Type Argument Description payload.streamIndex number the index number of this stream payload.rtc_id number &lt;optional&gt; the rtc_id / leg_id payload.remote_member_id string &lt;optional&gt; the id of the Member the stream belongs to payload.name string &lt;optional&gt; the stream's display name payload.stream MediaStream the stream that is activated payload.audio_mute boolean &lt;optional&gt; if the audio is muted Source: modules/media.js, line 19 × Search results Close "},"NexmoApiError.html":{"id":"NexmoApiError.html","title":"Class: NexmoApiError","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: NexmoApiError NexmoApiError Error constructor of an API-error new NexmoApiError(error) Parameters: Name Type Description error object API error, always containing {type: } Source: nexmoClientError.js, line 52 × Search results Close "},"NexmoClient.html":{"id":"NexmoClient.html","title":"Class: NexmoClient","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: NexmoClient NexmoClient new NexmoClient(params) The parent NexmoClient class. Parameters: Name Type Description params object the settings to initialise the SDK Properties Name Type Default Description debug Boolean 'silent' set mode to 'debug', 'info', 'warn', or 'error' for customized logging levels in the console url string 'nexmo_ws_url' Nexmo Conversation Websocket url, default is wss://ws.nexmo.com (wss://ws-us-1.nexmo.com for WDC, wss://ws-us-2.nexmo.com for DAL, wss://ws-eu-1.nexmo.com for LON, wss://ws-sg-1.nexmo.com for SNG) nexmo_api_url string Nexmo Conversation Api url, default is https://api.nexmo.com (https://api-us-1.nexmo.com for WDC, https://api-us-2.nexmo.com for DAL, https://api-eu-1.nexmo.com for LON, https://api-sg-1.nexmo.com for SNG) ips_url string 'ips_url' Nexmo IPS url for image upload, default is https://api.nexmo.com/v1/image (https://api-us-1.nexmo.com/v1/image for WDC, https://api-us-2.nexmo.com/v1/image for DAL, https://api-eu-1.nexmo.com/v1/image for LON, https://api-sg-1.nexmo.com/v1/image for SNG) path string '/rtc' Nexmo Conversation Websocket url path suffix rtcstats object set reporting for stream statistics (Websocket or internal event emit) Properties Name Type Default Description ws_url string endpoint (websocket) to send rtc stats. emit_events Boolean false receive rtcstats:report event socket_io object configure socket.io Properties Name Type Default Description forceNew Boolean true configure socket.io forceNew attribute autoConnect Boolean true socket.io autoConnect attribute reconnection Boolean true socket.io reconnection attribute reconnectionAttempts number 5 socket.io reconnectionAttempts attribute transports Array.&lt;string&gt; 'websocket' socket.io transports protocols sync Array.&lt;string&gt; 'lite' {'lite' || 'full' || 'none'} after a successful login, synchronise conversations, include events or nothing environment string 'production' development / production environment iceServers object [{'stun:stun.l.google.com:19302'} iceServers for RTCPeerConnection callstats object configure callstats.io integration Properties Name Type Default Description enabled Boolean false AppID string your callstats AppID AppSecret string your callstats AppSecret log_reporter object configure log reports for bugsnag tool Properties Name Type Default Description enabled Boolean true bugsnag_key string your bugsnag api key / defaults to Nexmo api key conversations_page_config object configure paginated requests for conversations Properties Name Type Default Description page_size number 10 the number of resources returned in a single request list order string asc 'asc' or 'desc' ordering of resources (usually based on creation time) cursor string cursor parameter to access the next or previous page of a data set events_page_config object configure paginated requests for events Properties Name Type Default Description page_size number 10 the number of resources returned in a single request list order string asc 'asc' or 'desc' ordering of resources (usually based on creation time) event_type string the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*' token string the jwt token for network requests iceGatherOnlyOneCandidate string false the flag for gathering one candidate or multiple in rtc ice gathering process Source: sdk.js, line 35 Fires: NexmoClient#event:connecting NexmoClient#event:disconnect NexmoClient#event:error NexmoClient#event:ready NexmoClient#event:reconnect NexmoClient#event:reconnecting Methods connect() Connect from the cloud. Source: sdk.js, line 696 disconnect() Disconnect from the cloud. Source: sdk.js, line 689 login(token) Login to the cloud. Parameters: Name Type Description token string the login token Source: sdk.js, line 549 Returns: the application we logged in Type Promise.&lt;Application&gt; logout() logout from the cloud. Source: sdk.js, line 643 Events connecting Connecting event. Source: sdk.js, line 203 Example Listen to websocket connecting event rtc.on(\"connecting\", () =&gt; { console.log(\"connecting\"); }); disconnect Disconnect event. Source: sdk.js, line 216 Example Listen to websocket disconnect event rtc.on(\"disconnect\", () =&gt; { console.log(\"disconnect\"); }); error Error event. Source: sdk.js, line 255 Example Listen to websocket error event rtc.on(\"error\", (error) =&gt; { console.log(\"error\", error); }); ready Ready event. Source: sdk.js, line 188 Example Listen to websocket ready event rtc.on(\"ready\", () =&gt; { console.log(\"connection ready\"); }); reconnect Reconnect event. Source: sdk.js, line 229 Example Listen to websocket reconnect event rtc.on(\"reconnect\", (retry_number) =&gt; { console.log(\"reconnect\", retry_number); }); reconnecting Reconnecting event. Source: sdk.js, line 242 Example Listen to websocket reconnecting event rtc.on(\"reconnecting\", (retry_number): void =&gt; { console.log(\"reconnecting\", retry_number); }); × Search results Close "},"NexmoClientError.html":{"id":"NexmoClientError.html","title":"Class: NexmoClientError","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: NexmoClientError NexmoClientError Error constructor of an NexmoClient-error new NexmoClientError(errorInput) Parameters: Name Type Description errorInput string String client error Source: nexmoClientError.js, line 24 × Search results Close "},"NXMCall.html":{"id":"NXMCall.html","title":"Class: NXMCall","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: NXMCall NXMCall new NXMCall(application, conversation, from) Conversation NXMCall Object. Parameters: Name Type Description application Application The Application object. conversation Conversation The Conversation object that belongs to this nxmCall. from Member The member that initiated the nxmCall. Properties: Name Type Default Description application Application The Application object that the nxmCall belongs to. conversation Conversation The Conversation object that belongs to this nxmCall. from Member The caller. The member object of the caller (not a reference to the one in conversation.members) to Map.&lt;string, Member&gt; The callees keyed by a member's id. The members that receive the nxmCall (not a reference to conversation.members) id String The nxmCall id (our member's leg_id, comes from rtc:answer event, or member:media) CALL_STATUS NXMCall.CALL_STATUS \"started\" the available nxmCall statuses direction NXMCall.CALL_DIRECTION the Direction of the nxmCall, Outbound, Inbound STATUS_PERMITTED_FLOW NXMCall.STATUS_PERMITTED_FLOW the permitted nxmCall status transition map, describes the \"from\" and allowed \"to\" transitions Source: modules/nxmCall.js, line 16 Fires: Application#member:call Application#call:status:changed Members &lt;static, readonly&gt; CALL_DIRECTION :string Enum for NXMCall direction. Type: string Properties: Name Type Default Description INBOUND string inbound The NXMCall started from another end OUTBOUND string outbound The NXMCall started from this client Source: modules/nxmCall.js, line 94 &lt;static, readonly&gt; CALL_STATUS :string Enum for NXMCall status. Type: string Properties: Name Type Default Description STARTED string started The NXMCall is in started status RINGING string ringing The NXMCall is in ringing status ANSWERED string answered The NXMCall is in answered status COMPLETED string completed The NXMCall is in completed status BUSY string busy The NXMCall is in busy status TIMEOUT string timeout The NXMCall is in timeout status UNANSWERED string unanswered The NXMCall is in unanswered status REJECTED string rejected The NXMCall is in rejected status FAILED string failed The NXMCall is in failed status Source: modules/nxmCall.js, line 68 &lt;static, readonly&gt; STATUS_PERMITTED_FLOW :Map.&lt;string, Set.&lt;NXMCall.CALL_STATUS&gt;&gt; Enum for the permitted call status transition. Type: Map.&lt;string, Set.&lt;NXMCall.CALL_STATUS&gt;&gt; Source: modules/nxmCall.js, line 107 Methods &lt;async&gt; answer( [autoPlayAudio]) Answers an incoming nxmCall Join the conversation that you are invited Create autoplay Audio object Parameters: Name Type Argument Default Description autoPlayAudio boolean &lt;optional&gt; true attach the audio stream automatically to start playing (default true) Source: modules/nxmCall.js, line 350 Returns: Type Promise.&lt;Audio&gt; hangUp( [reason]) Hangs up the nxmCall If there is a knocking active, do a knocking:delete otherwise Leave from the conversation Disable the audio Parameters: Name Type Argument Description reason object &lt;optional&gt; the reason for hanging up the nxmCall Properties Name Type Argument Description reason_code string &lt;optional&gt; the code of the reason reason_text string &lt;optional&gt; the description of the reason Source: modules/nxmCall.js, line 489 Returns: Type Promise hangUpIfAllLeft() Go through the members of the conversation and if .me is the only one (JOINED or INVITED) nxmCall nxmCall.hangUp(). Source: modules/nxmCall.js, line 190 Returns: empty promise or the nxmCall.hangUp promise chain Type Promise reject( [reason]) Rejects an incoming nxmCall Leave from the conversation that you are invited Parameters: Name Type Argument Description reason object &lt;optional&gt; the reason for rejecting the nxmCall Properties Name Type Argument Description reason_code string &lt;optional&gt; the code of the reason reason_text string &lt;optional&gt; the description of the reason Source: modules/nxmCall.js, line 540 Returns: Type Promise × Search results Close "},"NXMEvent.html":{"id":"NXMEvent.html","title":"Class: NXMEvent","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: NXMEvent NXMEvent new NXMEvent() Conversation NXMEvent Object. The super class that holds the base events that apply to common event objects. Source: events/nxmEvent.js, line 11 × Search results Close "},"TextEvent.html":{"id":"TextEvent.html","title":"Class: TextEvent","body":" DocStrap Classes ApplicationConversationConversationsPageEventsPageImageEventMediaMemberNexmoApiErrorNexmoClientNexmoClientErrorNXMCallNXMEventTextEvent Events Application#call:status:changedApplication#event:NXM-errorsApplication#member:callApplication#member:invitedApplication#member:joinedApplication#rtcstats:reportApplication#sync:progressConversation#audio:mute:offConversation#audio:mute:onConversation#event:deleteConversation#event:imageConversation#event:textConversation#image:seenConversation#member:call:statusConversation#member:invitedConversation#member:joinedConversation#member:leftConversation#member:mediaConversation#text:seenConversation#text:typing:offConversation#text:typing:onMember#media:stream:onNexmoClient#event:connectingNexmoClient#event:disconnectNexmoClient#event:errorNexmoClient#event:readyNexmoClient#event:reconnectNexmoClient#event:reconnecting Class: TextEvent TextEvent new TextEvent() A text event Source: events/text_event.js, line 13 Extends NXMEvent Methods del() Delete the event Overrides: NXMEvent#del Source: events/text_event.js, line 52 Returns: Type Promise delivered() Set the message status to 'delivered'. handled by the SDK Overrides: NXMEvent#delivered Source: events/text_event.js, line 45 Returns: Type Promise seen() Set the message status to 'seen' Overrides: NXMEvent#seen Source: events/text_event.js, line 37 Returns: Type Promise × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
